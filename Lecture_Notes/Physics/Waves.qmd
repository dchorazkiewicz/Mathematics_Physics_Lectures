---
title: Waves
format:
  html:
    theme: flatly
    grid:
      body-width: 1000px      # Domyślnie jest to ok. 800-900px
      margin-width: 250px  
    toc: true
    toc-depth: 3
    highlight-style: tango
    code-line-numbers: true
    code-fold: true
    code-summary: "Show the code"
    code-tools: true
    code-block-bg: "rgba(42, 174, 42, 0.02)"
    code-block-border-left: "#2aae2a"
    code-language-label: true
    css: styles.css
    math: mathjax
    self-contained: true
    other-links:
      - text: Main page
        href: https://dchorazkiewicz.github.io/Mathematics_Physics_Lectures
---


## Springs and Mechanical Waves

Mechanical waves arise as a result of the application of simple harmonic motion rules to interconnected systems. At their core, such waves can be visualized as particles connected by springs, where each particle's motion influences the next. This elegant interplay between force, displacement, and energy transfer forms the foundation of mechanical wave dynamics.

To illustrate this concept, imagine a chain of small masses connected by springs. When one mass is displaced, the motion propagates through the entire system, creating a wave-like pattern. You can explore this phenomenon in action with a simulation of ten masses linked by springs: 



<iframe src="html_anim/waves/oscilators_systems_waves.html" width="100%" height="700px" frameborder="0"></iframe>

[html_anim/waves/oscilators_systems_waves.html](html_anim/waves/oscilators_systems_waves.html)


## Plane Harmonic Wave 

A plane harmonic wave is a fundamental example of wave motion, described by a sinusoidal function such as:

$$
\psi(x, t) = A \sin(kx - \omega t + \phi),
$$

where:

- $A$ is the amplitude,
- $k$ is the wave number,
- $\omega$ is the angular frequency,
- $\phi$ is the phase constant,
- $x$ and $t$ represent position and time, respectively.


```{python}
import numpy as np
import matplotlib.pyplot as plt

# Parameters for the wave
A = 1.0  # Amplitude
lambda_wave = 4.0  # Wavelength
k = 2 * np.pi / lambda_wave  # Wave number
phi = 0  # Phase constant
x = np.linspace(0, 8, 1000)  # Range for x

# Wave function
psi = A * np.sin(k * x - phi)

# Plot the wave function
plt.figure(figsize=(12, 6))
plt.plot(x, psi, label="$\\psi(x) = A \\sin(kx - \\phi)$", color="blue")

# Mark the amplitude
plt.plot([lambda_wave / 4, lambda_wave / 4], [0, A], color="green", linewidth=2)
plt.text(lambda_wave / 4 + 0.2, A / 2, r'Amplitude $A$', fontsize=12, ha='left', color="green")

# Mark the segment from 1 to 5 with vertical lines at the ends
x_start = 1
x_end = 5
y_label = A + 0.3  # Position above the wave to mark the segment
plt.plot([x_start, x_end], [y_label, y_label], color="red", linewidth=2)  # Horizontal line
plt.plot([x_start, x_start], [y_label - 0.05, y_label + 0.05], color="red", linewidth=2)  # Vertical line at start
plt.plot([x_end, x_end], [y_label - 0.05, y_label + 0.05], color="red", linewidth=2)  # Vertical line at end
plt.text((x_start + x_end) / 2, y_label - 0.1, "$\\lambda$", fontsize=12, ha='center', color="red")  # Label above the segment

# Add auxiliary lines
plt.axhline(y=0, color='gray', linestyle='--', linewidth=0.7, alpha=0.5)  # Horizontal axis
plt.axhline(y=A, color='gray', linestyle='--', linewidth=0.7)  # Amplitude line
plt.axhline(y=-A, color='gray', linestyle='--', linewidth=0.7)  # Negative amplitude line

# Configure axes
plt.xlabel("Position $x$", fontsize=14)
plt.ylabel("Wave function $\\psi(x)$", fontsize=14)

# Add grid
plt.grid(True, linestyle="--", alpha=0.7)

# Display the plot
plt.show()


```

<iframe src="html_anim/waves/plane_wave_simulation.html" width="100%" height="600px" frameborder="0"></iframe>

[html_anim/waves/plane_wave_simulation.html](html_anim/waves/plane_wave_simulation.html)

### Constructing the Wave Equation

The temporal and spatial derivatives of the wave function $\psi(x, t)$ are key to understanding its behavior. The first and second derivatives with respect to time $t$ are:

$$
\frac{\partial \psi}{\partial t} = -A \omega \cos(kx - \omega t + \phi),
$$

$$
\frac{\partial^2 \psi}{\partial t^2} = -A \omega^2 \sin(kx - \omega t + \phi).
$$

Similarly, the first and second derivatives with respect to position $x$ are:

$$
\frac{\partial \psi}{\partial x} = A k \cos(kx - \omega t + \phi),
$$

$$
\frac{\partial^2 \psi}{\partial x^2} = -A k^2 \sin(kx - \omega t + \phi).
$$

By combining these derivatives, we can see how the wave function satisfies the general wave equation. Substituting $\frac{\partial^2 \psi}{\partial x^2}$ and $\frac{\partial^2 \psi}{\partial t^2}$ into:

$$
\frac{\partial^2 \psi}{\partial x^2} = \frac{1}{v^2} \frac{\partial^2 \psi}{\partial t^2},
$$

and using the relations $v = \frac{\omega}{k}$, it becomes clear that the sinusoidal wave satisfies this fundamental equation, connecting temporal and spatial changes in the wave function.

### General Implications

What we have derived here is not just a coincidence but is, in fact, the result of more general considerations. The equation we obtained, often called the wave equation, emerges from the fundamental principles governing wave phenomena. It describes the behavior of a wide range of wave-like systems, including sound waves, water waves, and even electromagnetic waves in certain contexts. As such, it is recognized as one of the cornerstone equations in the study of physical systems exhibiting wave motion.

Let us begin! First, we will derive the difference equations that allow for the numerical solution of the wave equation. Here is the plan:

### Difference Equation for the Wave Equation

Recall the wave equation in the form:

$$
\frac{\partial^2 \psi}{\partial x^2} = \frac{1}{v^2} \frac{\partial^2 \psi}{\partial t^2}.
$$

#### Discretization of Space and Time

Assume that:
- We divide the space $x$ into $N$ equal intervals of length $\Delta x$.
- We divide the time $t$ into steps of length $\Delta t$.

The function $\psi(x, t)$ is replaced by a discrete grid $\psi_i^n$, where $i$ denotes the spatial index and $n$ denotes the time index:

- $i = 0, 1, 2, \dots, N$,
- $n = 0, 1, 2, \dots$.

#### Finite Difference Approximations

1. **Second spatial derivatives**:
   Approximate $\frac{\partial^2 \psi}{\partial x^2}$ using central differences:
   $$
   \frac{\partial^2 \psi}{\partial x^2} \approx \frac{\psi_{i+1}^n - 2\psi_i^n + \psi_{i-1}^n}{\Delta x^2}.
   $$

2. **Second temporal derivatives**:
   Approximate $\frac{\partial^2 \psi}{\partial t^2}$ using central differences:
   $$
   \frac{\partial^2 \psi}{\partial t^2} \approx \frac{\psi_i^{n+1} - 2\psi_i^n + \psi_i^{n-1}}{\Delta t^2}.
   $$

#### Difference Equation

Substituting these into the wave equation, we obtain:
$$
\frac{\psi_{i+1}^n - 2\psi_i^n + \psi_{i-1}^n}{\Delta x^2} = \frac{1}{v^2} \frac{\psi_i^{n+1} - 2\psi_i^n + \psi_i^{n-1}}{\Delta t^2}.
$$

Simplifying, we solve for $\psi_i^{n+1}$:
$$
\psi_i^{n+1} = 2\psi_i^n - \psi_i^{n-1} + c^2 \left( \psi_{i+1}^n - 2\psi_i^n + \psi_{i-1}^n \right),
$$

where $c = \frac{v \Delta t}{\Delta x}$ is the Courant number, which must satisfy the stability condition $c \leq 1$.

---

### Numerical Implementation

1. **Initial state**: A string fixed at both ends ($\psi_0^n = \psi_N^n = 0$) with an initial triangular displacement.
2. **Time iteration**: Compute the state $\psi_i^{n+1}$ based on the states $\psi_i^n$ and $\psi_i^{n-1}$.
3. **Visualization**: Display several snapshots of the wave at different time intervals.

Next, I will prepare Python code to implement this algorithm.

The following code implements an explicit solution of the wave equation for a string fixed at both ends with an initial triangular displacement. The visualization shows the wave's propagation at various time intervals.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Parameters
L = 1.0          # Length of the string
T = 1.0          # Total simulation time
c = 1.0          # Wave speed
nx = 100         # Number of spatial points
nt = 500         # Number of time steps

dx = L / (nx - 1)            # Spatial step
dt = T / nt                  # Time step
r = c * dt / dx              # Courant number

# Initialize arrays
u = np.zeros((nt, nx))       # Solution at successive time steps
x = np.linspace(0, L, nx)    # x-coordinates

# Initial conditions: e.g., a sinusoidal-shaped initial displacement
u[0, :] = np.exp(-100 * (x - 0.5)**2)
u[1, :] = u[0, :]

# Boundary conditions: u(0, t) = u(L, t) = 0 (string fixed at ends)
u[:, 0] = 0
u[:, -1] = 0

# Time iteration
for n in range(1, nt - 1):
    for i in range(1, nx - 1):
        u[n + 1, i] = (2 * (1 - r**2) * u[n, i] -
                       u[n - 1, i] +
                       r**2 * (u[n, i + 1] + u[n, i - 1]))

# Select time snapshots for visualization
time_snapshots = [0, 10, 50, 100, 200, 300]
time_labels = [f'Time = {n*dt:.2f} s' for n in time_snapshots]

# Plot snapshots at selected time intervals
plt.figure(figsize=(10, 6))
for idx, n in enumerate(time_snapshots):
    plt.plot(x, u[n, :], label=time_labels[idx])

plt.xlabel('Position on the string')
plt.ylabel('Amplitude')
plt.title('Wave propagation on a string at selected time intervals')
plt.legend()
plt.grid(True)
plt.show()
```


same we can save in gif file

![](./py_src/wave_propagation.gif)

<iframe src="html_anim/waves/wave_equation_numerical.html" width="100%" height="600px" frameborder="0"></iframe>

[html_anim/waves/wave_equation_numerical.html](html_anim/waves/wave_equation_numerical.html)

## Intefeference of Waves

The interference of waves is a fascinating phenomenon that arises when two or more waves overlap in space and time. Depending on their relative phase and amplitude, the resulting interference can be constructive or destructive, leading to a variety of patterns and effects.

### Constructive Interference

Constructive interference occurs when two waves are in phase, meaning their peaks and troughs align. In this case, the amplitudes of the waves add up, resulting in a wave with a larger amplitude. This reinforcement of the waves leads to a constructive interference pattern, where the combined wave appears stronger than the individual waves.

### Destructive Interference

Destructive interference, on the other hand, arises when two waves are out of phase, with peaks aligning with troughs. In this scenario, the amplitudes of the waves cancel each other out, leading to a wave with a smaller amplitude or no wave at all. This destructive interference pattern results in regions of minimal or zero amplitude, where the waves effectively eliminate each other.

### Superposition Principle

The interference of waves is governed by the superposition principle, which states that the total displacement of a medium at any point and time is the sum of the displacements caused by each individual wave. This principle allows us to predict the resulting interference pattern by analyzing the properties of the individual waves.

### Visualization of Interference

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Parameters
A1 = 1.0  # Amplitude of wave 1
A2 = 0.8  # Amplitude of wave 2
k1 = 2.0  # Wave number of wave 1
k2 = 2.5  # Wave number of wave 2
omega1 = 1.0  # Angular frequency of wave 1
omega2 = 1.0  # Angular frequency of wave 2
phi1 = 0  # Phase of wave 1
phi2 = np.pi  # Phase of wave 2
t=0

x = np.linspace(0, 8, 1000)  # Range for x

# Wave functions
psi1 = A1 * np.sin(k1 * x + omega1 * t + phi1)
psi2 = A2 * np.sin(k2 * x + omega2 * t + phi2)
psi_total = psi1 + psi2

# Plot the wave functions
plt.figure(figsize=(12, 6))
plt.plot(x, psi1, label="$\\psi_1(x) = A_1 \\sin(k_1 x - \\omega_1 t + \\phi_1)$", color="blue")
plt.plot(x, psi2, label="$\\psi_2(x) = A_2 \\sin(k_2 x - \\omega_2 t + \\phi_2)$", color="red")
plt.plot(x, psi_total, label="$\\psi_{\\text{total}}(x) = \\psi_1(x) + \\psi_2(x)$", color="green")

# Add auxiliary lines
plt.axhline(y=0, color='gray', linestyle='--', linewidth=0.7, alpha=0.5)  # Horizontal axis

# Configure axes
plt.xlabel("Position $x$", fontsize=14)
plt.ylabel("Wave function $\\psi(x)$", fontsize=14)

# Add grid
plt.grid(True, linestyle="--", alpha=0.7)

# Display the plot
plt.legend()
plt.show()
```

<iframe src="html_anim/waves/interference.html" width="100%" height="900px" frameborder="0"></iframe>

[html_anim/waves/interference.html](html_anim/waves/interference.html)

## Huygens–Fresnel principle

The Huygens–Fresnel principle is a fundamental concept in wave optics that describes how every point on a wavefront can be considered as a source of secondary spherical waves. These secondary waves combine to form the wavefront at a later time, allowing us to predict the propagation of waves through various media and obstacles.

### Refraction

Refraction is a common phenomenon where waves change direction as they pass from one medium to another. The Huygens–Fresnel principle provides a simple explanation for refraction, showing how the secondary waves generated at each point on the wavefront propagate through the new medium, leading to a change in the wave's direction.

![source: Wikipedia](pics/waves/Refraction_-_Huygens-Fresnel_principle.svg) 



#### Snell's Law

Snell's Law is a key result derived from the Huygens–Fresnel principle, describing the relationship between the angles of incidence and refraction for waves passing through different media. The law states that the ratio of the sines of the angles is equal to the ratio of the wave speeds in the two media:

$$
\frac{\sin(\theta_1)}{\sin(\theta_2)} = \frac{v_1}{v_2},
$$

where $\theta_1$ and $\theta_2$ are the angles of incidence and refraction, respectively, and $v_1$ and $v_2$ are the wave speeds in the two media.

```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huygens-Fresnel Principle: Refraction</title>
    <style>
        .huygens-app {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            color: #333;
            box-sizing: border-box;
        }

        .huygens-app * {
            box-sizing: border-box;
        }

        .app-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .app-header h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.6rem;
        }

        .canvas-wrapper {
            width: 100%;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }

        #huygensCanvas {
            display: block;
            width: 100%;
            height: 450px;
        }

        .controls-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            background-color: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-row label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #555;
        }

        .val-display {
            font-family: monospace;
            color: #007bff;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .buttons-row {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            font-size: 0.95rem;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover { background-color: #0056b3; }

        .btn-reset {
            background-color: #6c757d;
            color: white;
        }
        .btn-reset:hover { background-color: #5a6268; }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .line { width: 20px; height: 3px; display: inline-block; }

        .alert-box {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            display: none;
        }

        @media (max-width: 600px) {
            .controls-container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="huygens-app">
    <div class="app-header">
        <h2>Huygens-Fresnel Refraction</h2>
        <p>Wavelets construction at the interface</p>
    </div>

    <div class="legend">
        <div class="legend-item">
            <span class="line" style="background: #007bff;"></span> Incident Wave
        </div>
        <div class="legend-item">
            <span class="dot" style="background: #ffc107;"></span> Secondary Sources
        </div>
        <div class="legend-item">
            <span class="line" style="border: 1px solid #28a745; height: 10px; width:10px; border-radius: 50%;"></span> Wavelets
        </div>
        <div class="legend-item">
            <span class="line" style="background: #dc3545;"></span> Refracted Wavefront
        </div>
    </div>

    <div class="canvas-wrapper">
        <canvas id="huygensCanvas"></canvas>
        <div id="tirAlert" class="alert-box">Total Internal Reflection!</div>
    </div>

    <div class="controls-container">
        <div class="control-group">
            <div class="control-row">
                <label>Medium 1 Index (n<sub>1</sub>)</label>
                <span id="val-n1" class="val-display">1.0</span>
            </div>
            <input type="range" id="n1" min="1.0" max="2.5" step="0.1" value="1.0">
            
            <div class="control-row">
                <label>Medium 2 Index (n<sub>2</sub>)</label>
                <span id="val-n2" class="val-display">1.5</span>
            </div>
            <input type="range" id="n2" min="1.0" max="2.5" step="0.1" value="1.5">

            <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                Velocity ratio (v<sub>1</sub>/v<sub>2</sub>) = <span id="val-ratio">1.50</span>
            </div>
        </div>

        <div class="control-group">
            <div class="control-row">
                <label>Incident Angle (&theta;<sub>1</sub>)</label>
                <span id="val-angle" class="val-display">45°</span>
            </div>
            <input type="range" id="angle" min="0" max="80" step="1" value="45">

            <div class="control-row">
                <label>Refracted Angle (&theta;<sub>2</sub>)</label>
                <span id="val-angle2" class="val-display">--</span>
            </div>

            <div class="control-row">
                <label>Animation Speed</label>
            </div>
            <input type="range" id="speed" min="0.1" max="2.0" step="0.1" value="0.5">
        </div>

        <div class="buttons-row">
            <button id="btn-play" class="btn btn-primary">Pause</button>
            <button id="btn-reset" class="btn btn-reset">Reset Wave</button>
        </div>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('huygensCanvas');
        const ctx = canvas.getContext('2d');
        const tirAlert = document.getElementById('tirAlert');

        // UI Refs
        const ui = {
            n1: document.getElementById('n1'),
            n2: document.getElementById('n2'),
            angle: document.getElementById('angle'),
            speed: document.getElementById('speed'),
            vn1: document.getElementById('val-n1'),
            vn2: document.getElementById('val-n2'),
            vang: document.getElementById('val-angle'),
            vang2: document.getElementById('val-angle2'),
            vratio: document.getElementById('val-ratio'),
            btnPlay: document.getElementById('btn-play'),
            btnReset: document.getElementById('btn-reset')
        };

        // State
        let state = {
            n1: 1.0,
            n2: 1.5,
            theta1: 45 * Math.PI / 180, // radians
            speed: 0.5,
            time: 0,
            running: true
        };

        // Constants
        const BASE_VELOCITY = 100; // pixels per second (base c)
        let width, height;
        let sources = [];

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            width = rect.width;
            height = rect.height;
            initSources();
        }

        function initSources() {
            sources = [];
            const numSources = 12;
            const step = width / (numSources + 2); // padding
            for(let i=1; i<=numSources; i++) {
                sources.push({ x: i * step, y: height/2, hitTime: null });
            }
        }

        function updatePhysics() {
            // Snell's Law: n1 * sin(t1) = n2 * sin(t2)
            const sinT2 = (state.n1 / state.n2) * Math.sin(state.theta1);
            let theta2 = 0;
            let isTIR = false;

            if (Math.abs(sinT2) > 1.0) {
                isTIR = true;
                theta2 = null;
            } else {
                theta2 = Math.asin(sinT2);
            }

            // Velocities
            const v1 = BASE_VELOCITY / state.n1;
            const v2 = BASE_VELOCITY / state.n2;

            return { v1, v2, theta2, isTIR };
        }

        function resetWave() {
            state.time = -2; // Start slightly before
            sources.forEach(s => s.hitTime = null);
        }

        function draw() {
            const { v1, v2, theta2, isTIR } = updatePhysics();
            
            // Update UI
            ui.vang2.textContent = isTIR ? "TIR" : (theta2 * 180 / Math.PI).toFixed(1) + "°";
            ui.vratio.textContent = (state.n2 / state.n1).toFixed(2);
            tirAlert.style.display = isTIR ? 'block' : 'none';

            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw Media Backgrounds
            const midY = height / 2;
            
            // Medium 1 (Top)
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, midY);
            
            // Medium 2 (Bottom)
            ctx.fillStyle = "#f1f3f5"; // Slight gray
            ctx.fillRect(0, midY, width, midY);

            // Draw Interface Line
            ctx.beginPath();
            ctx.moveTo(0, midY);
            ctx.lineTo(width, midY);
            ctx.strokeStyle = "#adb5bd";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Normal (Dashed)
            ctx.beginPath();
            ctx.moveTo(width/2, 20);
            ctx.lineTo(width/2, height - 20);
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = "#999";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            // --- Draw Rays ---
            const centerX = width/2;
            const rayLen = 300;
            
            // Incident Ray (Medium 1)
            // Starts top left usually if theta > 0
            const ix = centerX - rayLen * Math.sin(state.theta1);
            const iy = midY - rayLen * Math.cos(state.theta1);
            
            ctx.beginPath();
            ctx.moveTo(ix, iy);
            ctx.lineTo(centerX, midY);
            ctx.strokeStyle = "rgba(0, 123, 255, 0.4)";
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Refracted Ray (Medium 2)
            if (!isTIR) {
                const rx = centerX + rayLen * Math.sin(theta2);
                const ry = midY + rayLen * Math.cos(theta2);
                ctx.beginPath();
                ctx.moveTo(centerX, midY);
                ctx.lineTo(rx, ry);
                ctx.strokeStyle = "rgba(0, 123, 255, 0.4)";
                ctx.stroke();
            }

            // --- Wavefront Simulation ---
            
            const distance = state.time * v1; // Distance of wavefront from center along ray direction
            
            // Calculate hit times for sources
            // The wave hits the interface at different times.
            // Based on geometry, time delay relative to center is: x_rel * sin(theta) / v1
            
            sources.forEach(s => {
                const proj = (s.x - centerX) * Math.sin(state.theta1);
                s.hitTime = (proj / v1); 
            });

            // 1. Draw Incident Wavefront (The one that triggers Huygens)
            
            if (state.time < 1.5) { // Only draw if relevant
                // Calculation of wavefront position
                // The wavefront is perpendicular to the ray direction.
                // Its position along the ray is given by 'distance' (v1 * t).
                // Center of wavefront (intersection with ray):
                // Ray goes from Top-Left to Center. Direction vector D = (sin t1, cos t1).
                // At t=0, it's at Center. At t<0, it's at Center + t*v1*D = Center - |dist|*D.
                // Or simply: P = Center + (v1*t)*D. Since t is signed, this works.
                
                const rX = centerX + distance * Math.sin(state.theta1); // Changed - to + to fix direction
                const rY = midY + distance * Math.cos(state.theta1); // Changed - to + to fix direction
                
                // Note: since 't' starts negative, (v1*t) is negative.
                // We want to be at Top-Left. 
                // CenterX + (negative) * (positive_sin) = Left. Correct.
                // MidY + (negative) * (positive_cos) = Top. Correct.
                // The previous version used '-' which flipped it to Bottom-Right.

                // Perpendicular vector (-cos t1, sin t1)
                const pX = -Math.cos(state.theta1);
                const pY = Math.sin(state.theta1);
                const L = 600;

                ctx.beginPath();
                ctx.moveTo(rX - pX*L, rY - pY*L);
                ctx.lineTo(rX + pX*L, rY + pY*L);
                ctx.strokeStyle = "#007bff";
                ctx.lineWidth = 2;
                // Clip to top half
                ctx.save();
                ctx.rect(0,0,width,midY);
                ctx.clip();
                ctx.stroke();
                ctx.restore();
            }

            // 2. Draw Secondary Sources and Wavelets
            sources.forEach(s => {
                // Draw source dot
                ctx.beginPath();
                ctx.arc(s.x, s.y, 4, 0, Math.PI*2);
                ctx.fillStyle = "#ffc107";
                ctx.fill();

                // Check if wave has hit this source
                if (state.time > s.hitTime) {
                    const dt = state.time - s.hitTime;
                    const radius = v2 * dt;

                    // Draw Wavelet (Semi-circle in Medium 2)
                    if (!isTIR && radius > 0) {
                        ctx.beginPath();
                        ctx.arc(s.x, s.y, radius, 0, Math.PI, false);
                        ctx.strokeStyle = "rgba(40, 167, 69, 0.6)"; // Greenish
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            });

            // 3. Draw Refracted Wavefront (Envelope)
            
            if (!isTIR && state.time > -0.5) {
                const dist2 = v2 * state.time;
                // For refracted wave (t > 0), it moves away from center into Medium 2.
                // Direction D2 = (sin t2, cos t2).
                // Position P2 = Center + (v2*t)*D2.
                const rX2 = centerX + dist2 * Math.sin(theta2);
                const rY2 = midY + dist2 * Math.cos(theta2);
                
                // Perpendicular vector (-cos t2, sin t2)
                const pX2 = -Math.cos(theta2);
                const pY2 = Math.sin(theta2);
                const L2 = 600;

                ctx.beginPath();
                ctx.moveTo(rX2 - pX2*L2, rY2 - pY2*L2);
                ctx.lineTo(rX2 + pX2*L2, rY2 + pY2*L2);
                ctx.strokeStyle = "#dc3545"; // Red
                ctx.lineWidth = 3;
                
                // Clip to bottom half
                ctx.save();
                ctx.rect(0, midY, width, height - midY);
                ctx.clip();
                ctx.stroke();
                ctx.restore();
            }

        }

        function animate() {
            if (state.running) {
                state.time += 0.016 * state.speed; // approx 60fps
                
                // Auto reset if too far
                if (state.time > 4.0) {
                    state.time = -2.0;
                }
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Interaction
        function updateFromUI() {
            state.n1 = parseFloat(ui.n1.value);
            state.n2 = parseFloat(ui.n2.value);
            state.theta1 = parseFloat(ui.angle.value) * Math.PI / 180;
            state.speed = parseFloat(ui.speed.value);

            ui.vn1.textContent = state.n1.toFixed(1);
            ui.vn2.textContent = state.n2.toFixed(1);
            ui.vang.textContent = ui.angle.value + "°";
            
            if (!state.running) draw();
        }

        [ui.n1, ui.n2, ui.angle, ui.speed].forEach(el => {
            el.addEventListener('input', updateFromUI);
        });

        ui.btnPlay.addEventListener('click', () => {
            state.running = !state.running;
            ui.btnPlay.textContent = state.running ? "Pause" : "Resume";
        });

        ui.btnReset.addEventListener('click', () => {
            resetWave();
            if (!state.running) draw();
        });

        window.addEventListener('resize', resize);
        
        // Init
        resize();
        resetWave();
        updateFromUI();
        animate();

    })();
</script>

</body>
</html>
```

### Diffraction

Diffraction is another key concept explained by the Huygens–Fresnel principle, where waves bend around obstacles or pass through narrow openings. By considering each point on the wavefront as a source of secondary waves, we can predict how the diffracted waves will propagate and create interference patterns.

![source: Wikipedia](pics/waves/Refraction_on_an_aperture_-_Huygens-Fresnel_principle.svg) 

![source: Wikipedia](pics/waves/Wavelength%3Dslitwidth.gif){width=50%}


```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffraction & Interference Explorer</title>
    <style>
        /* Scoped styles */
        .diffraction-app {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            color: #333;
            box-sizing: border-box;
        }

        .diffraction-app * {
            box-sizing: border-box;
        }

        .app-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .app-header h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.6rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .tab-btn {
            padding: 10px 20px;
            background: #e9ecef;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            color: #495057;
            transition: all 0.2s;
            font-size: 1rem;
        }

        .tab-btn.active {
            background: #007bff;
            color: white;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }

        /* Canvas Area */
        .canvas-container {
            width: 100%;
            background-color: #000;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        #diffCanvas {
            background-color: #111;
            cursor: crosshair;
            width: 100%;
            height: 400px;
        }

        /* Legend overlay */
        .legend-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
        }
        .legend-row { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        .line { width: 20px; height: 2px; }

        /* Controls */
        .controls-panel {
            background-color: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #555;
            display: flex;
            justify-content: space-between;
        }

        .val-display {
            font-family: monospace;
            color: #007bff;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

    </style>
</head>
<body>

<div class="diffraction-app">
    <div class="app-header">
        <h2>Huygens-Fresnel: Diffraction & Interference</h2>
    </div>

    <div class="tabs">
        <button class="tab-btn active" onclick="switchMode('single')">Single Slit Diffraction</button>
        <button class="tab-btn" onclick="switchMode('double')">Double Slit Interference</button>
    </div>

    <div class="canvas-container">
        <canvas id="diffCanvas"></canvas>
        <div class="legend-overlay">
            <div class="legend-row"><span class="dot" style="background: #ffd700;"></span> <span>Secondary Sources</span></div>
            <div class="legend-row"><span class="line" style="border-top: 2px dashed #32cd32;"></span> <span>Huygens Wavelets</span></div>
            <div class="legend-row"><span class="line" style="background: #ff4d4d; height: 3px;"></span> <span>Mean Intensity</span></div>
        </div>
    </div>

    <div class="controls-panel">
        <div class="control-group">
            <div class="control-label">
                <label>Wavelength (&lambda;)</label>
                <span id="val-lambda" class="val-display">--</span>
            </div>
            <input type="range" id="slider-lambda" min="20" max="60" step="1" value="35">
        </div>

        <div class="control-group">
            <div class="control-label">
                <label>Slit Width (a)</label>
                <span id="val-width" class="val-display">--</span>
            </div>
            <input type="range" id="slider-width" min="10" max="100" step="5" value="60">
        </div>

        <div class="control-group" id="group-separation" style="display: none; opacity: 0.5;">
            <div class="control-label">
                <label>Slit Separation (d)</label>
                <span id="val-sep" class="val-display">--</span>
            </div>
            <input type="range" id="slider-sep" min="40" max="150" step="5" value="80" disabled>
        </div>
        
        <div class="control-group">
             <div class="control-label">
                <label>Simulation Quality</label>
             </div>
             <label style="font-size: 0.85rem; cursor: pointer;">
                <input type="checkbox" id="chk-wavelets" checked> Show Huygens Arcs
             </label>
             <label style="font-size: 0.85rem; cursor: pointer;">
                <input type="checkbox" id="chk-field" checked> Show Field Map
             </label>
        </div>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('diffCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency

        // UI Elements
        const sliderLambda = document.getElementById('slider-lambda');
        const sliderWidth = document.getElementById('slider-width');
        const sliderSep = document.getElementById('slider-sep');
        const groupSep = document.getElementById('group-separation');
        const valLambda = document.getElementById('val-lambda');
        const valWidth = document.getElementById('val-width');
        const valSep = document.getElementById('val-sep');
        const chkWavelets = document.getElementById('chk-wavelets');
        const chkField = document.getElementById('chk-field');
        const tabs = document.querySelectorAll('.tab-btn');

        // State
        let mode = 'single'; // 'single' or 'double'
        let time = 0;
        let sources = [];
        let animationId;
        
        // Physics Parameters
        let lambda = 35;
        let slitWidth = 60;
        let separation = 80;
        let speed = 2.0;

        // Configuration
        const GRAPH_WIDTH = 150; // Width of the intensity graph panel on the right

        // Render Scale (Optimization)
        let width, height;
        let simWidth; // Width of the wave simulation area
        let imageData;
        let fieldBuf; // Buffer for calculated field values

        function init() {
            window.switchMode = function(newMode) {
                mode = newMode;
                tabs.forEach(t => t.classList.remove('active'));
                if(mode === 'single') {
                    tabs[0].classList.add('active');
                    groupSep.style.display = 'none';
                    groupSep.style.opacity = '0.3';
                    sliderSep.disabled = true;
                } else {
                    tabs[1].classList.add('active');
                    groupSep.style.display = 'flex';
                    groupSep.style.opacity = '1';
                    sliderSep.disabled = false;
                }
                updateSources();
            };

            resize();
            updateSources();
            animate();
        }

        function resize() {
            const rect = canvas.getBoundingClientRect();
            
            // Ensure valid dimensions to prevent IndexSizeError if layout isn't ready
            let newWidth = Math.floor(rect.width);
            let newHeight = Math.floor(rect.height);

            // Fallback dimensions
            if (newWidth === 0 || newHeight === 0) {
                newWidth = 800;
                newHeight = 400;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;
            width = newWidth;
            height = newHeight;
            simWidth = width - GRAPH_WIDTH;
            
            // Re-create buffers with valid dimensions
            imageData = ctx.createImageData(width, height);
            fieldBuf = new Float32Array(height);
            
            updateSources();
        }

        function updateSources() {
            sources = [];
            const barrierX = simWidth * 0.25; // Barrier position
            const centerY = height / 2;
            
            // Density of Huygens sources (points per pixel)
            const density = 0.15; // 1 source every ~6-7 pixels

            if (mode === 'single') {
                const numPoints = Math.max(3, Math.floor(slitWidth * density));
                const startY = centerY - slitWidth/2;
                
                for(let i=0; i<=numPoints; i++) {
                    const y = startY + (i / numPoints) * slitWidth;
                    sources.push({ x: barrierX, y: y });
                }
            } else {
                // Double Slit
                const numPoints = Math.max(2, Math.floor(slitWidth * density));
                
                // Top slit
                let startY = centerY - separation/2 - slitWidth/2;
                for(let i=0; i<=numPoints; i++) {
                    const y = startY + (i / numPoints) * slitWidth;
                    sources.push({ x: barrierX, y: y });
                }

                // Bottom slit
                startY = centerY + separation/2 - slitWidth/2;
                for(let i=0; i<=numPoints; i++) {
                    const y = startY + (i / numPoints) * slitWidth;
                    sources.push({ x: barrierX, y: y });
                }
            }
        }

        function calculateField() {
            // Guard clause if initialization failed
            if (!imageData) return;

            const k = (2 * Math.PI) / lambda;
            const barrierX = simWidth * 0.25;
            
            // Phase for animation: k*r - omega*t
            const phaseT = (2 * Math.PI * time * speed) / lambda; 

            const ptr = imageData.data;
            const showField = chkField.checked;

            const sx = new Float32Array(sources.length);
            const sy = new Float32Array(sources.length);
            for(let s=0; s<sources.length; s++) { sx[s] = sources[s].x; sy[s] = sources[s].y; }
            const numSources = sources.length;
            
            // 1. Calculate Field Map (Time Dependent)
            let idx = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // --- GRAPH AREA (RIGHT SIDE) ---
                    if (x >= simWidth) {
                        ptr[idx] = 0; idx += 4; continue; 
                    }

                    // --- SIMULATION AREA (LEFT SIDE) ---
                    let val = 0;
                    if (x < barrierX) {
                        // Plane wave
                        val = Math.sin((2 * Math.PI * x) / lambda - phaseT);
                    } else {
                        // Interference
                        if (showField) {
                            for (let s = 0; s < numSources; s++) {
                                const dx = x - sx[s];
                                const dy = y - sy[s];
                                const r = Math.sqrt(dx*dx + dy*dy);
                                const amp = 10.0 / (Math.sqrt(r) + 1.0); 
                                const phase = k * r - phaseT;
                                val += amp * Math.sin(phase);
                            }
                            val = val / Math.sqrt(numSources); 
                        }
                    }

                    // Draw
                    if (showField) {
                        let intensity = 128 + val * 80;
                        if (intensity < 0) intensity = 0; 
                        if (intensity > 255) intensity = 255;
                        ptr[idx] = intensity; ptr[idx+1] = intensity; ptr[idx+2] = intensity; ptr[idx+3] = 255;
                    } else {
                        ptr[idx] = 20; ptr[idx+1] = 20; ptr[idx+2] = 20; ptr[idx+3] = 255;
                    }
                    idx += 4;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);

            // 2. Calculate Screen Intensity (Time Averaged / Static)
            // We calculate this separately for the screen line (x = simWidth)
            // Intensity ~ Amplitude^2. E_total = sum(A_i * exp(i*k*r_i))
            // We sum phasors components: sum(cos(kr)) and sum(sin(kr))
            
            const screenX = simWidth - 1;

            for (let y = 0; y < height; y++) {
                let sumSin = 0;
                let sumCos = 0;
                
                for (let s = 0; s < numSources; s++) {
                    const dx = screenX - sx[s];
                    const dy = y - sy[s];
                    const r = Math.sqrt(dx*dx + dy*dy);
                    
                    const amp = 10.0 / (Math.sqrt(r) + 1.0);
                    const kr = k * r; // Phase without time component
                    
                    sumSin += amp * Math.sin(kr);
                    sumCos += amp * Math.cos(kr);
                }

                // Average Intensity ~ Amplitude Squared
                // Amplitude = sqrt(sumSin^2 + sumCos^2)
                // We divide by numSources to normalize to similar scale as field map
                const amplitudeSq = (sumSin*sumSin + sumCos*sumCos) / numSources;
                
                // Store Amplitude (envelope) in buffer so we can square it later for Intensity graph
                // or just store the value we want to plot. 
                // Let's store amplitude, so graph calculates Amplitude^2 = Intensity
                fieldBuf[y] = Math.sqrt(amplitudeSq);
            }
        }

        function drawOverlay() {
            const barrierX = simWidth * 0.25;
            const centerY = height / 2;

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, simWidth, height);
            ctx.clip();

            // Draw Barrier
            ctx.fillStyle = "#555";
            if (mode === 'single') {
                ctx.fillRect(barrierX - 2, 0, 4, centerY - slitWidth/2);
                ctx.fillRect(barrierX - 2, centerY + slitWidth/2, 4, height);
            } else {
                ctx.fillRect(barrierX - 2, 0, 4, centerY - separation/2 - slitWidth/2);
                ctx.fillRect(barrierX - 2, centerY - separation/2 + slitWidth/2, 4, separation - slitWidth);
                ctx.fillRect(barrierX - 2, centerY + separation/2 + slitWidth/2, 4, height);
            }

            // Draw Sources
            ctx.fillStyle = "#ffd700";
            sources.forEach(s => {
                ctx.beginPath();
                ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw Huygens Wavelets
            if (chkWavelets.checked) {
                ctx.strokeStyle = "rgba(50, 205, 50, 0.6)"; 
                ctx.lineWidth = 1;
                const offset = (time * speed) % lambda;
                const numArcs = 15; 
                ctx.beginPath();
                sources.forEach(s => {
                    for(let n=1; n<=numArcs; n++) {
                        const r = n * lambda - offset;
                        if (r > 0 && r < simWidth - barrierX) {
                            ctx.moveTo(s.x + r * Math.cos(-Math.PI/2), s.y + r * Math.sin(-Math.PI/2));
                            ctx.arc(s.x, s.y, r, -Math.PI/2, Math.PI/2);
                        }
                    }
                });
                ctx.setLineDash([2, 4]); 
                ctx.stroke();
                ctx.setLineDash([]);
            }
            ctx.restore(); 

            // Draw Intensity Graph
            drawIntensityGraph();
        }

        function drawIntensityGraph() {
            // Divider
            ctx.beginPath();
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 2;
            ctx.moveTo(simWidth, 0);
            ctx.lineTo(simWidth, height);
            ctx.stroke();

            ctx.fillStyle = "#888";
            ctx.font = "12px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Screen Plane", simWidth + GRAPH_WIDTH/2, 20);

            // Graph
            const startX = simWidth + 10;
            const scaleI = 8; 

            ctx.beginPath();
            ctx.strokeStyle = "#ff4d4d";
            ctx.lineWidth = 2;
            
            for (let y = 0; y < height; y++) {
                const Amp = fieldBuf[y];
                const I = Amp * Amp; // Intensity is Amplitude squared
                
                const px = startX + (I * scaleI); 
                
                if (y === 0) ctx.moveTo(px, y);
                else ctx.lineTo(px, y);
            }
            ctx.stroke();

            // Baseline
            ctx.beginPath();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.moveTo(startX, 0);
            ctx.lineTo(startX, height);
            ctx.stroke();
        }

        function animate() {
            time++;
            lambda = parseInt(sliderLambda.value);
            slitWidth = parseInt(sliderWidth.value);
            separation = parseInt(sliderSep.value);
            
            valLambda.textContent = lambda;
            valWidth.textContent = slitWidth;
            valSep.textContent = separation;

            updateSources();
            calculateField();
            drawOverlay();

            animationId = requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resize);
        init();

    })();
</script>

</body>
</html>
```


## Doppler Effect

The Doppler effect is a well-known phenomenon where the frequency of a wave changes due to the relative motion between the source and observer. The Huygens–Fresnel principle provides a theoretical framework for understanding the Doppler effect, showing how the wavefronts shift and compress or expand based on the motion of the source and observer.

This effect can be visualized with the following animations (source: Wikipedia):

:::{layout-ncol="2"}
![](pics/waves/Dopplereffectstationary.gif)

![](pics/waves/Dopplereffectsourcemovingrightatmach0.7.gif)

![](pics/waves/Dopplereffectsourcemovingrightatmach1.0.gif)

![](pics/waves/Dopplereffectsourcemovingrightatmach1.4.gif)
:::

```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doppler Effect Simulation</title>
    <style>
        .doppler-app {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            color: #333;
            box-sizing: border-box;
        }

        .doppler-app * {
            box-sizing: border-box;
        }

        .app-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .app-header h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.6rem;
        }

        .canvas-container {
            width: 100%;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        #dopplerCanvas {
            background-color: #ffffff;
            cursor: default;
            width: 100%;
            height: 400px;
            display: block;
        }

        /* Overlay info like current Mach number */
        .info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            border: 1px solid #ddd;
            font-family: monospace;
            color: #007bff;
            font-weight: bold;
        }

        .controls-panel {
            background-color: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider-row label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #555;
            display: flex;
            justify-content: space-between;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .buttons-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .preset-btn {
            padding: 8px 16px;
            background: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            color: #495057;
        }

        .preset-btn:hover {
            background: #dee2e6;
            border-color: #adb5bd;
        }

        .control-btn {
            padding: 8px 24px;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            color: white;
            min-width: 100px;
        }

        .btn-play { background-color: #28a745; }
        .btn-play:hover { background-color: #218838; }
        
        .btn-pause { background-color: #dc3545; }
        .btn-pause:hover { background-color: #c82333; }

        .btn-reset { background-color: #6c757d; }
        .btn-reset:hover { background-color: #5a6268; }

    </style>
</head>
<body>

<div class="doppler-app">
    <div class="app-header">
        <h2>Doppler Effect Simulation</h2>
    </div>

    <div class="canvas-container">
        <canvas id="dopplerCanvas"></canvas>
        <div class="info-overlay" id="status-display">Mach: 0.00</div>
    </div>

    <div class="controls-panel">
        <div class="slider-row">
            <label>
                Source Velocity (Mach Number)
                <span id="val-mach" style="color: #007bff;">0.00</span>
            </label>
            <input type="range" id="slider-mach" min="0" max="2.5" step="0.1" value="0">
        </div>

        <div class="buttons-row">
            <button class="preset-btn" onclick="setMach(0)">Stationary (v=0)</button>
            <button class="preset-btn" onclick="setMach(0.5)">Subsonic (v=0.5c)</button>
            <button class="preset-btn" onclick="setMach(1.0)">Sonic Boom (v=1.0c)</button>
            <button class="preset-btn" onclick="setMach(1.5)">Supersonic (v=1.5c)</button>
            <button class="preset-btn" onclick="setMach(2.0)">Mach 2.0</button>
        </div>

        <div class="buttons-row" style="border: none; padding-top: 5px;">
            <button id="btn-play" class="control-btn btn-pause">Pause</button>
            <button id="btn-reset" class="control-btn btn-reset">Reset</button>
        </div>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('dopplerCanvas');
        const ctx = canvas.getContext('2d');
        const statusDisplay = document.getElementById('status-display');
        
        // Controls
        const sliderMach = document.getElementById('slider-mach');
        const valMach = document.getElementById('val-mach');
        const btnPlay = document.getElementById('btn-play');
        const btnReset = document.getElementById('btn-reset');

        // Physics Constants
        const WAVE_SPEED = 2.0; // Pixels per frame
        const EMISSION_INTERVAL = 15; // Frames between wave emissions

        // State
        let width, height;
        let isRunning = true;
        let frameCount = 0;
        
        // Simulation State
        let machNumber = 0.0;
        let sourceX = 0;
        let sourceY = 0;
        
        // Array of wave objects: { x: number, y: number, r: number, opacity: number }
        let waves = [];

        function resize() {
            const rect = canvas.getBoundingClientRect();
            // High DPI support
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            // Logical size
            width = rect.width;
            height = rect.height;
            
            // Reset position to center if stationary, or left if moving
            resetSim();
        }

        function resetSim() {
            waves = [];
            sourceY = height / 2;
            
            // Initial position depends on speed strategy.
            // For this sim, we will start center-left to allow movement to the right.
            if (machNumber === 0) {
                sourceX = width / 2;
            } else {
                sourceX = width * 0.2; 
            }
        }

        function update() {
            if (!isRunning) return;

            // Update Waves (Expansion)
            for (let i = waves.length - 1; i >= 0; i--) {
                waves[i].r += WAVE_SPEED;
                waves[i].opacity -= 0.002; // Slow fade
                if (waves[i].opacity <= 0 || waves[i].r > width * 1.5) {
                    waves.splice(i, 1);
                }
            }

            // Emit new wave
            if (frameCount % EMISSION_INTERVAL === 0) {
                waves.push({
                    x: sourceX,
                    y: sourceY,
                    r: 0,
                    opacity: 1.0
                });
            }

            // Move Source
            const sourceSpeed = machNumber * WAVE_SPEED;
            sourceX += sourceSpeed;

            // Loop / Auto-reset logic
            // If source goes too far off screen, reset to start to create a loop effect
            if (sourceX > width + 100) {
                 // Soft reset: Move source back, clear waves that are too far gone?
                 // Or hard reset. Hard reset is cleaner for loop visualization.
                 resetSim();
            }

            frameCount++;
        }

        function draw() {
            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw Grid (Optional, faint)
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
            for(let y=0; y<height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
            ctx.stroke();

            // Draw Waves
            ctx.lineWidth = 2;
            
            for (const wave of waves) {
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.r, 0, Math.PI * 2);
                // Color logic: blue-ish
                ctx.strokeStyle = `rgba(0, 123, 255, ${wave.opacity})`;
                ctx.stroke();
            }

            // Draw Source
            ctx.beginPath();
            ctx.arc(sourceX, sourceY, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#dc3545'; // Red
            ctx.fill();
            
            // Draw Velocity Vector (Visual aid)
            if (machNumber > 0) {
                ctx.beginPath();
                ctx.moveTo(sourceX, sourceY);
                ctx.lineTo(sourceX + 30, sourceY);
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrowhead
                ctx.beginPath();
                ctx.moveTo(sourceX + 30, sourceY);
                ctx.lineTo(sourceX + 25, sourceY - 3);
                ctx.lineTo(sourceX + 25, sourceY + 3);
                ctx.fill();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // --- Interaction ---

        window.setMach = function(val) {
            sliderMach.value = val;
            updateParams();
            // Force reset on major mode change to make it clean
            resetSim();
        };

        function updateParams() {
            machNumber = parseFloat(sliderMach.value);
            valMach.textContent = machNumber.toFixed(2);
            statusDisplay.textContent = `Mach: ${machNumber.toFixed(2)}`;
            
            // Dynamic labels based on physics
            if (machNumber === 0) statusDisplay.textContent += " (Stationary)";
            else if (machNumber < 1) statusDisplay.textContent += " (Subsonic)";
            else if (Math.abs(machNumber - 1.0) < 0.05) statusDisplay.textContent += " (Sonic Boom)";
            else statusDisplay.textContent += " (Supersonic)";
        }

        sliderMach.addEventListener('input', updateParams);

        btnPlay.addEventListener('click', () => {
            isRunning = !isRunning;
            if (isRunning) {
                btnPlay.textContent = "Pause";
                btnPlay.classList.remove('btn-play');
                btnPlay.classList.add('btn-pause');
            } else {
                btnPlay.textContent = "Resume";
                btnPlay.classList.remove('btn-pause');
                btnPlay.classList.add('btn-play');
            }
        });

        btnReset.addEventListener('click', () => {
            resetSim();
            if (!isRunning) {
                draw();
            }
        });

        window.addEventListener('resize', resize);

        // Init
        resize();
        loop();

    })();
</script>

</body>
</html>
```

#### Vapor cone ([Wikipedia](https://en.wikipedia.org/wiki/Vapor_cone))

The vapor cone, also known as the shock collar or shock egg, is a visible cloud of condensed water droplets that can sometimes form around an object moving at high speeds. This phenomenon is often associated with supersonic aircraft and other high-speed vehicles, where the pressure difference between the front and rear of the object leads to the condensation of water vapor in the air.

![source: Wikipedia](pics/waves/FA-18_going_transonic.jpeg)

#### Playground for waves:

- [Wave applet](https://phet.colorado.edu/sims/html/wave-on-a-string/latest/wave-on-a-string_all.html)

- [Heat versus Wave Equation](https://x.com/gabrielpeyre/status/1765255995809305064?t=pzuMHd7gpN1penkJplRkQg)

- [Video of Doppler Effect on the street](https://youtu.be/ffg4TOpXZyg?si=PxLSJtInPxolERYb)

- [Doppler Effect simulator](https://ophysics.com/waves11.html)

- [Interference applet](https://phet.colorado.edu/sims/html/wave-interference/latest/wave-interference_all.html)


## Cummulative wave

A supersonic plane is flying at a speed greater than the speed of sound, emitting sound waves that reach an observer at a fixed time. The animation shows the plane's trajectory, the sound waves emitted at different times, and the impulses that reach the observer simultaneously.

```{=html}
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulacja Fali Skumulowanej</title>
    <style>
        .sim-app {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            color: #333;
            box-sizing: border-box;
        }

        .sim-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .sim-header h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.5rem;
        }

        .sim-header p {
            font-size: 0.9rem;
            color: #666;
            margin: 0;
        }

        .canvas-container {
            width: 100%;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        #simCanvas {
            background-color: #ffffff;
            cursor: default;
            width: 100%;
            height: 500px;
            display: block;
        }

        .controls-container {
            border-top: 1px solid #eee;
            padding-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .speed-control {
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .speed-control label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #555;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .btn {
            padding: 8px 24px;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            color: white;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.9; }

        .btn-play { background-color: #28a745; }
        .btn-pause { background-color: #dc3545; }
        .btn-reset { background-color: #6c757d; }

        .status-bar {
            margin-top: 5px;
            text-align: center;
            font-family: monospace;
            font-size: 1rem;
            color: #007bff;
        }
    </style>
</head>
<body>

<div class="sim-app">
    <div class="sim-header">
        <h2>Simultaneous Arrival (Cumulative Wave)</h2>
        <p>Supersonic plane (v=2c) approaching an observer</p>
    </div>

    <div class="canvas-container">
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="status-bar" id="timeDisplay">Time: 0.00s / 5.00s</div>

    <div class="controls-container">
        <div class="speed-control">
            <label>Prędkość animacji: <span id="speedVal">1.0x</span></label>
            <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>

        <div class="buttons">
            <button id="btnPlay" class="btn btn-play">Start</button>
            <button id="btnReset" class="btn btn-reset">Reset</button>
        </div>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const timeDisplay = document.getElementById('timeDisplay');
        const btnPlay = document.getElementById('btnPlay');
        const btnReset = document.getElementById('btnReset');
        const speedSlider = document.getElementById('speedSlider');
        const speedVal = document.getElementById('speedVal');

        // Physics Parameters
        const c = 1.0;          // Speed of sound
        const v = 2.0;          // Speed of plane
        const T = 5.0;          // Impact time
        const IMPULSE_INTERVAL = 0.5; // Seconds

        // State
        let currentTime = 0;
        let isRunning = false;
        let animationId;
        let width, height;
        let scale = 1;
        let simSpeed = 1.0;

        // Data structures
        let impulses = []; 
        
        // Pre-calculate trajectory for static line drawing
        const trajectoryPoints = [];

        function precomputeTrajectory() {
            const steps = 500;
            for(let i=0; i<=steps; i++) {
                const t = (i / steps) * T; 
                const safeT = Math.min(t, T - 1e-4);
                
                const r = c * (T - safeT);
                const term = Math.sqrt(v*v - c*c) / c;
                const theta = term * Math.log(T / (T - safeT));
                
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);
                trajectoryPoints.push({x, y});
            }
        }

        function resize() {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            width = rect.width;
            height = rect.height;

            const maxCoord = c * T * 1.1; 
            const minDim = Math.min(width, height);
            scale = (minDim / 2) / maxCoord;

            drawFrame();
        }

        function getPlanePos(t) {
            const safeT = Math.min(t, T - 1e-6);
            const r = c * (T - safeT);
            const term = Math.sqrt(v*v - c*c) / c;
            const theta = term * Math.log(T / (T - safeT));
            
            return {
                x: r * Math.cos(theta),
                y: r * Math.sin(theta)
            };
        }

        function update(dt) {
            if (!isRunning) return;

            // Apply speed multiplier
            const step = dt * simSpeed;
            
            const prevTime = currentTime;
            currentTime += step;
            
            if (currentTime >= T) {
                currentTime = T;
                isRunning = false;
                btnPlay.textContent = "Replay";
                btnPlay.classList.remove('btn-pause');
                btnPlay.classList.add('btn-play');
            }

            // Check for new impulse emission
            const startIdx = Math.floor(prevTime / IMPULSE_INTERVAL) + 1;
            const endIdx = Math.floor(currentTime / IMPULSE_INTERVAL);

            for(let i = startIdx; i <= endIdx; i++) {
                const emitTime = i * IMPULSE_INTERVAL;
                if (emitTime < T) {
                    const pos = getPlanePos(emitTime);
                    impulses.push({
                        emitTime: emitTime,
                        x: pos.x,
                        y: pos.y
                    });
                }
            }
        }

        function drawFrame() {
            ctx.clearRect(0, 0, width, height);
            
            // --- TRANSFORMED WORLD SPACE ---
            ctx.save();
            ctx.translate(width/2, height/2);
            ctx.scale(scale, -scale); 

            // 1. Draw Static Trajectory (Blue dashed)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.4)';
            ctx.lineWidth = 2 / scale;
            ctx.setLineDash([5 / scale, 5 / scale]);
            if (trajectoryPoints.length > 0) {
                ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);
                for(let i=1; i<trajectoryPoints.length; i++) {
                    ctx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. Draw Observer (Dot only)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(0, 0, 0.15, 0, Math.PI*2);
            ctx.fill();
            
            // 3. Draw Impulses (Red Circles)
            ctx.lineWidth = 1.5 / scale;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
            
            for (let imp of impulses) {
                const r = c * (currentTime - imp.emitTime);
                if (r > 0) {
                    ctx.beginPath();
                    ctx.arc(imp.x, imp.y, r, 0, Math.PI*2);
                    ctx.stroke();
                }
            }

            // 4. Draw Plane (Black Dot)
            const planePos = getPlanePos(currentTime);
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(planePos.x, planePos.y, 0.1, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
            // --- END TRANSFORMED SPACE ---

            // 5. Draw Labels (Screen Space - No scaling artifacts)
            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            // Observer label at center + offset
            ctx.fillText("Observer", width/2 + 10, height/2 - 10);

            timeDisplay.textContent = `Time: ${currentTime.toFixed(2)}s / ${T.toFixed(2)}s`;
        }

        function loop() {
            if (isRunning) {
                update(0.016); 
            }
            drawFrame();
            animationId = requestAnimationFrame(loop);
        }

        // Interaction
        speedSlider.addEventListener('input', (e) => {
            simSpeed = parseFloat(e.target.value);
            speedVal.textContent = simSpeed.toFixed(1) + "x";
        });

        btnPlay.addEventListener('click', () => {
            if (currentTime >= T) {
                currentTime = 0;
                impulses = [];
                isRunning = true;
                btnPlay.textContent = "Pause";
                btnPlay.classList.remove('btn-play');
                btnPlay.classList.add('btn-pause');
            } else {
                isRunning = !isRunning;
                if(isRunning) {
                    btnPlay.textContent = "Pause";
                    btnPlay.classList.remove('btn-play');
                    btnPlay.classList.add('btn-pause');
                } else {
                    btnPlay.textContent = "Resume";
                    btnPlay.classList.remove('btn-pause');
                    btnPlay.classList.add('btn-play');
                }
            }
        });

        btnReset.addEventListener('click', () => {
            isRunning = false;
            currentTime = 0;
            impulses = [];
            btnPlay.textContent = "Start";
            btnPlay.classList.remove('btn-pause');
            btnPlay.classList.add('btn-play');
            drawFrame();
        });

        window.addEventListener('resize', resize);

        precomputeTrajectory();
        resize();
        loop();

    })();
</script>

</body>
</html>
```
