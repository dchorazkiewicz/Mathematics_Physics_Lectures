---
title: Language of Physics
format:
  html:
    theme: flatly
    toc: true
    toc-depth: 3
    highlight-style: tango
    code-line-numbers: true
    code-fold: true
    code-summary: "Show the code"
    code-tools: true
    code-block-bg: "rgba(42, 174, 42, 0.02)"
    code-block-border-left: "#2aae2a"
    code-language-label: true
    css: styles.css
    math: mathjax
    self-contained: true
    other-links:
      - text: Main page
        href: https://dchorazkiewicz.github.io/Mathematics_Physics_Lectures
---

## Introduction

Physics often describes the universe and its phenomena using the language of mathematics, where the Cartesian 3D space serves as the natural stage for physical events. This spatial representation, defined by three orthogonal axes $x$, $y$, and $z$, is the starting point for our exploration. By reducing the dimensionality to 2D, we simplify the analysis, enabling a focused study of structures that arise in such spaces. This reduction is not merely an abstraction but also a practical tool for understanding the behaviors and interactions within physical systems.


## Weather Data Visualization

Interactive weather maps serve as an excellent introduction to the fundamental ideas required to study physics. If one can interpret these maps, they will find it easier to grasp the basic concepts of scalar and vector fields, which are central to understanding physical systems.

On such maps, temperature is represented using a color gradient, where each color corresponds to a specific value at a given point in space. This visualization aligns with the definition of a **scalar field**, which assigns a single numerical value to each point in space. 

Similarly, wind patterns are illustrated using moving line segments, where their length and direction represent the speed and direction of the wind at various points. These segments directly depict **vector fields**, as they assign a vector—defined by both magnitude and direction—to each point in space. Since the magnitude is expressed as a numerical value, the background color can be used to represent the magnitude of the vector field.


```{=html}
<iframe width="650" height="450" src="https://embed.windy.com/embed2.html" frameborder="0" data-external="1"></iframe>

```

[www.windy.com](https://www.windy.com/)


Having this background, we can now delve into the mathematical representations of scalar and vector fields in 2D space. Let us use more formal definitions to understand these concepts better.

## Scalar Fields

A scalar field associates a single real value to every point in a given space. In 2D, this can be represented as a function $T(x, y)$, where $T$ could represent a physical property like temperature.

### Example: Temperature on a surface

Consider a simple model where the temperature of a surface varies with both position and time:

$$
T(x, y) = 5 \sin(x) \cos(y)
$$

Below is a Python code of this scalar field:

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Scalar field definition
def scalar_field(x, y):
    return  5 * np.sin(x) * np.cos(y)

# Generate grid points
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)
x, y = np.meshgrid(x, y)

# Compute scalar field values
T = scalar_field(x, y)

# Plot the scalar field
plt.figure(figsize=(8, 6))
plt.imshow(T, extent=[-5, 5, -5, 5], origin='lower', cmap="coolwarm")
plt.colorbar(label="Temperature")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.title("Temperature Distribution on a Surface")
plt.show()

```

Above example defines a scalar field that do not depend on time. As we can see on weather maps, scalar fields can also be time-dependent, where the value of the field changes with time.

To define a time-dependent scalar field, we can modify the previous example by adding explicit time dependence:

$$
T(x, y, t) = 5 \sin(x) \cos(y) e^{-t}
$$

Now the temperature at each point $(x, y)$ decays exponentially with time. To visualize this field, we can use the following Python

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Scalar field definition
def scalar_field(x, y, t):
    return 5 * np.sin(x) * np.cos(y) * np.exp(-t)

# Generate grid points
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)
x, y = np.meshgrid(x, y)

# Compute scalar field values for 4 time steps
T = np.zeros((100, 100, 4))
for i in range(4):
    T[:, :, i] = scalar_field(x, y, i)

# Determine common color scale
vmin = np.min(T)
vmax = np.max(T)

# Plot the scalar field for 4 time steps
fig, axs = plt.subplots(2, 2, figsize=(12, 12))

# Store the last image for the colorbar
im = None

for i, ax in enumerate(axs.flat):
    ax.grid(False)  # Explicitly disable gridlines
    im = ax.imshow(T[:, :, i], extent=[-5, 5, -5, 5], origin='lower', cmap="coolwarm", vmin=vmin, vmax=vmax)
    ax.set_title(f"Temperature Distribution at t={i}")
    ax.set_xlabel("X-axis")
    ax.set_ylabel("Y-axis")

# Adjust layout to fit a colorbar outside the plots
fig.subplots_adjust(right=0.85)
cbar_ax = fig.add_axes([0.88, 0.15, 0.02, 0.7])  # Define a new axis for the colorbar
cbar = fig.colorbar(im, cax=cbar_ax)
cbar.set_label("Temperature")

plt.show()

```

or we can simulate this in an html animation:

```{=html}
<div style="font-family: sans-serif; text-align: center; margin: 20px 0; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f9f9f9;">
    
    <div style="margin-bottom: 15px;">
        <label for="timeSlider" style="font-weight: bold;">Czas t: <span id="timeDisplay">0.00</span></label>
        <br>
        <input type="range" id="timeSlider" min="0" max="5" step="0.05" value="0" style="width: 80%; max-width: 400px; margin-top: 10px;">
    </div>

    <canvas id="scalarFieldCanvas" width="400" height="400" style="border: 1px solid #ccc; background-color: white;"></canvas>
    

    <script>
        (function() {
            const canvas = document.getElementById('scalarFieldCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('timeSlider');
            const timeDisplay = document.getElementById('timeDisplay');
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Konfiguracja zakresu
            const xMin = -5, xMax = 5;
            const yMin = -5, yMax = 5;
            
            // Maksymalna wartość amplitudy dla t=0 (do stałej skali kolorów)
            const globalMax = 5.0; 

            // Funkcja pola skalarnego
            function scalarField(x, y, t) {
                return 5 * Math.sin(x) * Math.cos(y) * Math.exp(-t);
            }

            // Funkcja mapująca wartość na kolor (Blue -> White -> Red)
            function valueToColor(val) {
                // Normalizacja wartości do zakresu [-1, 1] względem globalnego maksimum
                let norm = val / globalMax;
                
                let r, g, b;
                
                if (norm > 0) {
                    // Pozytywne - od białego do czerwonego
                    // norm = 0 -> biały (255,255,255), norm = 1 -> czerwony (255,0,0)
                    const intensity = Math.floor(255 * (1 - Math.min(norm, 1)));
                    r = 255;
                    g = intensity;
                    b = intensity;
                } else {
                    // Negatywne - od białego do niebieskiego
                    // norm = 0 -> biały, norm = -1 -> niebieski (0,0,255)
                    const intensity = Math.floor(255 * (1 - Math.min(Math.abs(norm), 1)));
                    r = intensity;
                    g = intensity;
                    b = 255;
                }
                return `rgb(${r},${g},${b})`;
            }

            function draw(t) {
                // Tworzymy obraz piksel po pikselu dla wydajności przy animacji
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                for (let py = 0; py < height; py++) {
                    // Mapowanie piksela na współrzędną Y (odwracamy oś Y, aby góra była dodatnia)
                    const y = yMax - (py / height) * (yMax - yMin);
                    
                    for (let px = 0; px < width; px++) {
                        // Mapowanie piksela na współrzędną X
                        const x = xMin + (px / width) * (xMax - xMin);
                        
                        const val = scalarField(x, y, t);
                        
                        // Obliczanie koloru
                        // Musimy to zrobić ręcznie dla imageData
                        let norm = val / globalMax;
                        let r, g, b;

                        if (norm > 0) {
                            let intensity = 255 * (1 - Math.min(norm, 1));
                            r = 255;
                            g = intensity;
                            b = intensity;
                        } else {
                            let intensity = 255 * (1 - Math.min(Math.abs(norm), 1));
                            r = intensity;
                            g = intensity;
                            b = 255;
                        }

                        const index = (py * width + px) * 4;
                        data[index] = r;     // Red
                        data[index + 1] = g; // Green
                        data[index + 2] = b; // Blue
                        data[index + 3] = 255; // Alpha
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }

            // Obsługa zdarzeń
            slider.addEventListener('input', function() {
                const t = parseFloat(this.value);
                timeDisplay.innerText = t.toFixed(2);
                
                // Używamy requestAnimationFrame dla płynności
                window.requestAnimationFrame(() => draw(t));
            });

            // Pierwsze rysowanie
            draw(0);
        })();
    </script>
</div>
```

## Vector Fields

A vector field assigns a vector to every point in space. In 2D, such a field can be represented as 

$$\vec{F}(x, y) = (F_x(x, y), F_y(x, y))$$

where $F_x$ and $F_y$ are the components of the vector field. Both may depend on the position $(x, y)$.

### Example: Static vector field

Let us examine a vector field that depends on both space and time:

$$
\vec{F}(x, y) = (\sin(y), \sqrt{\frac{|x|}{5}})
$$

This field might represent the velocity of a fluid at each point $(x, y)$ in a 2D space. Below is a Python code to visualize this vector field:

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Definition of the vector field
def vector_field(x, y):
    Fx = np.sin(y)
    Fy = np.sqrt(np.abs(x)/5)
    return Fx, Fy

# Generating a grid of points
x = np.linspace(-15, 15, 16)
y = np.linspace(-15, 15, 16)
x, y = np.meshgrid(x, y)

# Calculating the vector field
Fx, Fy = vector_field(x, y)

# Calculating the lengths of the vectors
d_lengths = np.sqrt(Fx**2 + Fy**2)

# Initializing the plot
fig, ax = plt.subplots(figsize=(6, 6))
quiver = ax.quiver(
    x, y, Fx, Fy, d_lengths, angles='xy', scale_units='xy', scale=1, cmap='viridis'
)
cb = fig.colorbar(quiver, ax=ax, label="Vector length")
ax.set_xlim(-15, 15)
ax.set_ylim(-15, 15)
ax.set_xlabel("X axis")
ax.set_ylabel("Y axis")
ax.set_title("2D vector field with color dependent on vector length")

plt.show()
```


Stream plot

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Definition of the vector field
def vector_field(x, y):
    Fx = np.sin(y)
    Fy = np.sqrt(np.abs(x)/5)
    return Fx, Fy

# Generating a grid of points
x = np.linspace(-15, 15, 100)  # Higher resolution for streamlines
y = np.linspace(-15, 15, 100)
x, y = np.meshgrid(x, y)

# Calculating the vector field
Fx, Fy = vector_field(x, y)
d_lengths = np.sqrt(Fx**2 + Fy**2)

# Streamplot (Streamlines)
fig, ax = plt.subplots(figsize=(6, 6))
stream = ax.streamplot(
    x[0, :], y[:, 0], Fx, Fy, color=d_lengths, cmap='viridis', linewidth=1.5
)
cb = fig.colorbar(stream.lines, ax=ax, label="Vector length")
ax.set_xlim(-15, 15)
ax.set_ylim(-15, 15)
ax.set_xlabel("X axis")
ax.set_ylabel("Y axis")
ax.set_title("2D Vector Field with Streamlines")
plt.show()
```

### Examples in html

```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>River Flow Simulation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f4;
            color: #333;
            user-select: none; /* Prevents text selection while dragging */
        }

        .container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
            text-align: center;
        }

        canvas {
            border-left: 0;
            border-right: 0;
            background-color: #e3f2fd;
            cursor: crosshair;
            margin: 0 auto;
            width: 100%;
            max-width: 600px;
            height: 300px;
            display: block;
            touch-action: none; /* Important for touch dragging */
        }

        .river-bank {
            height: 20px;
            width: 100%;
            max-width: 600px;
            background-color: #5d4037;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        .bank-top { border-radius: 4px 4px 0 0; border-bottom: 2px solid #3e2723; }
        .bank-bottom { border-radius: 0 0 4px 4px; border-top: 2px solid #3e2723; }

        .controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: opacity 0.2s;
            min-width: 100px;
        }
        
        button:hover { opacity: 0.9; }

        .btn-pause { background-color: #f57c00; }
        .btn-resume { background-color: #2e7d32; }
        .btn-clear { background-color: #d32f2f; }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f5f5f5;
            padding: 5px 10px;
            border-radius: 4px;
        }

        label {
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type=range] {
            cursor: pointer;
        }

        .status {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="controls">
            <button id="pauseBtn" class="btn-pause">Pause</button>
            <button id="clearBtn" class="btn-clear">Clear Particles</button>
            
            <div class="slider-group">
                <label for="speedSlider">Flow Speed (V<sub>max</sub>): <span id="speedVal">5.0</span></label>
                <input type="range" id="speedSlider" min="0" max="15" step="0.5" value="5">
            </div>
        </div>

        <div class="river-bank bank-top"></div>
        <canvas id="simulationCanvas" width="600" height="300"></canvas>
        <div class="river-bank bank-bottom"></div>

        <p class="status">Click and drag to place particles. Pause to arrange them, then Resume.</p>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const speedSlider = document.getElementById('speedSlider');
        const speedVal = document.getElementById('speedVal');
        const clearBtn = document.getElementById('clearBtn');
        const pauseBtn = document.getElementById('pauseBtn');

        // Simulation State
        let particles = [];
        let maxSpeed = parseFloat(speedSlider.value);
        let isPaused = false;
        let isDragging = false;
        
        // Constants
        const GRID_SPACING = 40; 
        const PARTICLE_COLOR = '#d32f2f';
        const VECTOR_COLOR = 'rgba(0, 60, 160, 0.4)';

        // --- Physics & Math ---

        // Velocity profile: V(y) = Vmax * sin(y_normalized * PI)
        function getVelocity(y) {
            const H = canvas.height;
            // Map y to 0..PI range
            const arg = (y / H) * Math.PI;
            // Prevent negative speeds (just in case)
            if (arg < 0 || arg > Math.PI) return 0;
            return maxSpeed * Math.sin(arg);
        }

        // --- Drawing ---

        function drawArrow(x, y, vel) {
            const visualScale = 6.0; 
            const length = vel * visualScale;
            
            // Do not draw tiny arrows
            if (length < 2) return;

            ctx.strokeStyle = VECTOR_COLOR;
            ctx.fillStyle = VECTOR_COLOR;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + length, y);
            ctx.stroke();

            // Arrowhead
            const headSize = 5;
            ctx.beginPath();
            ctx.moveTo(x + length, y);
            ctx.lineTo(x + length - headSize, y - headSize * 0.6);
            ctx.lineTo(x + length - headSize, y + headSize * 0.6);
            ctx.fill();
        }

        function drawVectorField() {
            // Draw a grid of vectors
            for (let y = GRID_SPACING / 2; y < canvas.height; y += GRID_SPACING) {
                for (let x = GRID_SPACING / 2; x < canvas.width; x += GRID_SPACING) {
                    const v = getVelocity(y);
                    drawArrow(x, y, v);
                }
            }
        }

        function drawParticles() {
            ctx.fillStyle = PARTICLE_COLOR;
            for (let p of particles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Main Loop ---

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Background (Vector Field)
            drawVectorField();

            // 2. Physics Update (only if running)
            if (!isPaused) {
                for (let p of particles) {
                    const v = getVelocity(p.y);
                    p.x += v;
                }
                // Remove particles that went off-screen
                particles = particles.filter(p => p.x < canvas.width + 10);
            }

            // 3. Draw Particles
            drawParticles();

            requestAnimationFrame(update);
        }

        // --- Interaction ---

        function addParticle(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            // Simple collision check to prevent stacking too many particles in one spot
            // (Optional, keeps it cleaner)
            const tooClose = particles.some(p => Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5);
            if (!tooClose) {
                particles.push({ x, y });
            }
        }

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            addParticle(e.clientX, e.clientY);
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                addParticle(e.clientX, e.clientY);
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Touch Events (for mobile/tablet)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            isDragging = true;
            addParticle(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (isDragging) {
                addParticle(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isDragging = false;
        });

        // UI Controls
        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            if (isPaused) {
                pauseBtn.innerText = "Resume";
                pauseBtn.className = "btn-resume";
            } else {
                pauseBtn.innerText = "Pause";
                pauseBtn.className = "btn-pause";
            }
        });

        clearBtn.addEventListener('click', () => {
            particles = [];
        });

        speedSlider.addEventListener('input', (e) => {
            maxSpeed = parseFloat(e.target.value);
            speedVal.innerText = maxSpeed.toFixed(1);
        });

        // Start
        update();
    </script>
</body>
</html>
```

## Derivatives and Integrals

### Derivatives

#### Derivative of functions of one variable

The derivative of a function $f(x)$ with respect to $x$ is defined as

$$
\frac{df(x)}{dx} = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}
$$

This limit represents the rate of change of the function $f(x)$ with respect to $x$.

#### Derivative of functions of two variables

The derivative of a function $f(x, y)$ with respect to $x$ is defined as

$$
\frac{\partial f(x, y)}{\partial x} = \lim_{h \to 0} \frac{f(x + h, y) - f(x, y)}{h}
$$

This limit represents the rate of change of the function $f(x, y)$ with respect to $x$. The derivative is a measure of how the function changes as $x$ changes for a fixed value of $y$. This describes how the function changes in the $x$ direction.

Similarly, the derivative of a function $f(x, y)$ with respect to $y$ is defined as

$$
\frac{\partial f(x, y)}{\partial y} = \lim_{h \to 0} \frac{f(x, y + h) - f(x, y)}{h}
$$

This limit represents the rate of change of the function $f(x, y)$ with respect to $y$ and describes how the function changes in the $y$ direction for a fixed value of $x$.

#### Html example

```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Derivative Visualization</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            background-color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            margin: 20px;
            display: flex;
            flex-direction: column;
            height: 90vh;
        }

        /* Tabs styling */
        .tabs {
            display: flex;
            background-color: #e0e0e0;
            border-radius: 8px 8px 0 0;
        }

        .tab-btn {
            flex: 1;
            padding: 15px;
            border: none;
            background-color: transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
            border-bottom: 3px solid transparent;
        }

        .tab-btn:hover {
            background-color: #d0d0d0;
        }

        .tab-btn.active {
            background-color: white;
            border-bottom: 3px solid #1976d2;
            color: #1976d2;
        }

        /* Content styling */
        .tab-content {
            display: none;
            flex: 1;
            padding: 20px;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }

        label {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        input[type=range] {
            cursor: pointer;
        }

        .plot-area {
            flex: 1;
            width: 100%;
            min-height: 400px;
            position: relative;
        }

        .math-val {
            font-family: monospace;
            color: #d32f2f;
        }

        /* Legend helpers */
        .legend-item {
            display: inline-block;
            margin-right: 15px;
            font-size: 0.9em;
        }
        .dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
    </style>
</head>
<body>

<div class="container">
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('ordinary')">Ordinary Derivative (1D)</button>
        <button class="tab-btn" onclick="switchTab('partial')">Partial Derivatives (2D/3D)</button>
    </div>

    <!-- TAB 1: ORDINARY DERIVATIVE -->
    <div id="tab-ordinary" class="tab-content active">
        <div class="controls">
            <div class="control-group">
                <label>Point position (x): <span id="ord-x-val" class="math-val">1.00</span></label>
                <input type="range" id="ord-x" min="-2.5" max="2.5" step="0.05" value="1.0">
            </div>
            <div class="control-group">
                <label>Step size (h / &epsilon;): <span id="ord-h-val" class="math-val">1.00</span></label>
                <input type="range" id="ord-h" min="0.01" max="2.0" step="0.01" value="1.0">
            </div>
            <div style="font-size: 0.85em; color: #666; max-width: 400px;">
                Function: <span style="font-family: monospace">f(x) = 0.5x³ - x</span><br>
                Move 'h' close to 0 to see the secant line become the tangent.
            </div>
        </div>
        <div id="plot-ordinary" class="plot-area"></div>
    </div>

    <!-- TAB 2: PARTIAL DERIVATIVES -->
    <div id="tab-partial" class="tab-content">
        <div class="controls">
            <div class="control-group">
                <label>X position: <span id="part-x-val" class="math-val">1.00</span></label>
                <input type="range" id="part-x" min="-2.5" max="2.5" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Y position: <span id="part-y-val" class="math-val">1.00</span></label>
                <input type="range" id="part-y" min="-2.5" max="2.5" step="0.1" value="1.0">
            </div>
            <div style="font-size: 0.85em; color: #666;">
                Function: <span style="font-family: monospace">f(x,y) = sin(x) * cos(y)</span><br>
                <span style="color:red">Red:</span> Slice y=const (∂f/∂x). <span style="color:blue">Blue:</span> Slice x=const (∂f/∂y).
            </div>
        </div>
        <div id="plot-partial" class="plot-area"></div>
    </div>
</div>

<script>
    // --- GLOBAL HELPERS ---
    function switchTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        
        document.getElementById('tab-' + tabName).classList.add('active');
        document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');
        
        // Trigger resize for Plotly to adjust to new visibility
        window.dispatchEvent(new Event('resize'));
    }

    // --- TAB 1 LOGIC: ORDINARY DERIVATIVE ---
    const ordXSlider = document.getElementById('ord-x');
    const ordHSlider = document.getElementById('ord-h');
    const ordXVal = document.getElementById('ord-x-val');
    const ordHVal = document.getElementById('ord-h-val');

    // Function f(x) = 0.5x^3 - x
    function f1(x) {
        return 0.5 * Math.pow(x, 3) - x;
    }

    // Derivative f'(x) = 1.5x^2 - 1 (for analytical tangent)
    function df1(x) {
        return 1.5 * Math.pow(x, 2) - 1;
    }

    function drawOrdinary() {
        const x0 = parseFloat(ordXSlider.value);
        const h = parseFloat(ordHSlider.value);
        const x1 = x0 + h;

        ordXVal.innerText = x0.toFixed(2);
        ordHVal.innerText = h.toFixed(2);

        // 1. Prepare main curve data
        const xRange = [];
        const yRange = [];
        for (let i = -3.5; i <= 3.5; i += 0.1) {
            xRange.push(i);
            yRange.push(f1(i));
        }

        // 2. Points
        const y0 = f1(x0);
        const y1 = f1(x1);

        // 3. Secant Line (Difference Quotient)
        // Passes through (x0, y0) and (x1, y1)
        // Equation: y - y0 = m * (x - x0) -> y = m(x-x0) + y0
        const m_secant = (y1 - y0) / (x1 - x0); // This is the difference quotient
        
        const secantX = [x0 - 1, x1 + 1];
        const secantY = [
            m_secant * (secantX[0] - x0) + y0,
            m_secant * (secantX[1] - x0) + y0
        ];

        // 4. Tangent Line (Actual Derivative limit)
        // y = f'(x0)(x - x0) + y0
        const m_tangent = df1(x0);
        const tangentX = [x0 - 1, x0 + 1.5]; // Shorter range
        const tangentY = [
            m_tangent * (tangentX[0] - x0) + y0,
            m_tangent * (tangentX[1] - x0) + y0
        ];

        // 5. Visual Triangle (Delta Y, Delta X)
        const triX = [x0, x1, x1, x0];
        const triY = [y0, y0, y1, y0];

        const data = [
            // Main Function
            {
                x: xRange, y: yRange,
                mode: 'lines', line: {color: '#444', width: 2},
                name: 'f(x)'
            },
            // Difference Quotient Triangle
            {
                x: triX, y: triY,
                mode: 'lines',
                line: {color: 'rgba(0,0,0,0.3)', width: 1, dash: 'dot'},
                fill: 'toself', fillColor: 'rgba(0,255,0,0.1)',
                name: 'Δx, Δy', showlegend: false
            },
            // Secant Line
            {
                x: secantX, y: secantY,
                mode: 'lines', line: {color: '#2e7d32', width: 3}, // Green
                name: 'Secant (Difference Quotient)'
            },
            // Tangent Line (Reference)
            {
                x: tangentX, y: tangentY,
                mode: 'lines', line: {color: '#d32f2f', width: 2, dash: 'dash'}, // Red dashed
                name: 'Tangent (Limit h→0)'
            },
            // Point A (x)
            {
                x: [x0], y: [y0],
                mode: 'markers', marker: {color: '#d32f2f', size: 10},
                name: 'x'
            },
            // Point B (x+h)
            {
                x: [x1], y: [y1],
                mode: 'markers', marker: {color: '#2e7d32', size: 10},
                name: 'x + h'
            }
        ];

        const layout = {
            title: 'Difference Quotient vs Derivative',
            xaxis: {title: 'x', range: [-3, 3]},
            yaxis: {title: 'f(x)', range: [-3, 3]},
            margin: {l: 50, r: 20, t: 40, b: 40},
            showlegend: true,
            legend: {x: 0, y: 1}
        };

        Plotly.newPlot('plot-ordinary', data, layout, {responsive: true, displayModeBar: false});
    }

    ordXSlider.addEventListener('input', drawOrdinary);
    ordHSlider.addEventListener('input', drawOrdinary);


    // --- TAB 2 LOGIC: PARTIAL DERIVATIVES ---
    const partXSlider = document.getElementById('part-x');
    const partYSlider = document.getElementById('part-y');
    const partXVal = document.getElementById('part-x-val');
    const partYVal = document.getElementById('part-y-val');

    // Function f(x,y) = sin(x)*cos(y)
    function f2(x, y) {
        return Math.sin(x) * Math.cos(y);
    }
    // Partial wrt x: cos(x)cos(y)
    function df2_dx(x, y) {
        return Math.cos(x) * Math.cos(y);
    }
    // Partial wrt y: -sin(x)sin(y)
    function df2_dy(x, y) {
        return -Math.sin(x) * Math.sin(y);
    }

    function drawPartial() {
        const x0 = parseFloat(partXSlider.value);
        const y0 = parseFloat(partYSlider.value);
        const z0 = f2(x0, y0);

        partXVal.innerText = x0.toFixed(2);
        partYVal.innerText = y0.toFixed(2);

        const range = 3.5;
        const step = 0.2;
        
        // 1. Surface Data
        const z_data = [];
        const x_axis = [];
        const y_axis = [];
        
        for (let y = -range; y <= range; y += step) {
            const row = [];
            y_axis.push(y);
            for (let x = -range; x <= range; x += step) {
                if(y === -range) x_axis.push(x);
                row.push(f2(x, y));
            }
            z_data.push(row);
        }

        // 2. Slice X (Moving along X, Fixed Y=y0)
        const sliceX_x = [];
        const sliceX_y = [];
        const sliceX_z = [];
        for (let i = -range; i <= range; i += 0.1) {
            sliceX_x.push(i);
            sliceX_y.push(y0);
            sliceX_z.push(f2(i, y0));
        }

        // 3. Slice Y (Moving along Y, Fixed X=x0)
        const sliceY_x = [];
        const sliceY_y = [];
        const sliceY_z = [];
        for (let i = -range; i <= range; i += 0.1) {
            sliceY_x.push(x0);
            sliceY_y.push(i);
            sliceY_z.push(f2(x0, i));
        }

        // 4. Tangent Line X (Slope in X direction)
        const slopeX = df2_dx(x0, y0);
        // Parametric line: P + t * <1, 0, slopeX>
        const tanX_x = [x0 - 1, x0 + 1];
        const tanX_y = [y0, y0];
        const tanX_z = [z0 - slopeX, z0 + slopeX];

        // 5. Tangent Line Y (Slope in Y direction)
        const slopeY = df2_dy(x0, y0);
        // Parametric line: P + t * <0, 1, slopeY>
        const tanY_x = [x0, x0];
        const tanY_y = [y0 - 1, y0 + 1];
        const tanY_z = [z0 - slopeY, z0 + slopeY];


        const data = [
            // Surface
            {
                z: z_data,
                x: x_axis,
                y: y_axis,
                type: 'surface',
                colorscale: 'Viridis',
                opacity: 0.6,
                showscale: false,
                name: 'Surface'
            },
            // Slice X (Red curve)
            {
                type: 'scatter3d', mode: 'lines',
                x: sliceX_x, y: sliceX_y, z: sliceX_z,
                line: {width: 5, color: 'red'},
                name: 'Cut y=const (∂f/∂x)'
            },
            // Tangent X
            {
                type: 'scatter3d', mode: 'lines',
                x: tanX_x, y: tanX_y, z: tanX_z,
                line: {width: 8, color: '#ff8a80'},
                name: 'Tangent X'
            },
            // Slice Y (Blue curve)
            {
                type: 'scatter3d', mode: 'lines',
                x: sliceY_x, y: sliceY_y, z: sliceY_z,
                line: {width: 5, color: 'blue'},
                name: 'Cut x=const (∂f/∂y)'
            },
            // Tangent Y
            {
                type: 'scatter3d', mode: 'lines',
                x: tanY_x, y: tanY_y, z: tanY_z,
                line: {width: 8, color: '#82b1ff'},
                name: 'Tangent Y'
            },
            // Point P
            {
                type: 'scatter3d', mode: 'markers',
                x: [x0], y: [y0], z: [z0],
                marker: {size: 6, color: 'black'},
                name: 'Point P'
            }
        ];

        const layout = {
            title: 'Partial Derivatives (Slices)',
            margin: {l: 0, r: 0, b: 0, t: 30},
            scene: {
                aspectmode: 'cube',
                xaxis: {title: 'X'},
                yaxis: {title: 'Y'},
                zaxis: {title: 'Z'}
            },
            showlegend: true,
            legend: {x: 0, y: 1}
        };

        Plotly.react('plot-partial', data, layout, {responsive: true, displayModeBar: false});
    }

    partXSlider.addEventListener('input', drawPartial);
    partYSlider.addEventListener('input', drawPartial);


    // Initial draw
    drawOrdinary();
    // Use timeout to ensure DOM is ready for Plotly size calculation
    setTimeout(drawPartial, 100);

    // Handle Resize
    window.addEventListener('resize', () => {
        Plotly.Plots.resize('plot-ordinary');
        Plotly.Plots.resize('plot-partial');
    });

</script>

</body>
</html>
```

### Integrals

At the simplest level, an integral is the reverse of a derivative. The integral of a function $f(x)$ with respect to $x$ is defined as

$$
\int f(x) dx = F(x) + C
$$

where $F(x)$ is the antiderivative of $f(x)$ and $C$ is an integration constant. The antiderivative is a function whose derivative is equal to $f(x)$:

$$
\frac{dF(x)}{dx} = f(x)
$$

The integral is a measure of the area under the curve of the function $f(x)$. The integral is a function that gives the area under the curve of the function $f(x)$ up to a given point.
 
### Html example

```{=html}
<!-- Load Plotly once per page. If your Quarto doc already loads it, you can remove this script tag. -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

<div class="integration-vis-container" style="font-family: sans-serif; border: 1px solid #ddd; border-radius: 8px; background: #fff; margin: 20px 0; overflow: hidden; max-width: 100%;">
    
    <!-- TABS HEADER -->
    <div style="display: flex; background: #f5f5f5; border-bottom: 1px solid #ddd;">
        <button id="btn-tab-riemann" style="flex: 1; padding: 15px; border: none; background: transparent; cursor: pointer; font-weight: bold; color: #555; border-bottom: 3px solid transparent;">
            1. Definite Integral (Area)
        </button>
        <button id="btn-tab-line" style="flex: 1; padding: 15px; border: none; background: transparent; cursor: pointer; font-weight: bold; color: #555; border-bottom: 3px solid transparent;">
            2. Line Integral (Work)
        </button>
    </div>

    <!-- TAB 1: RIEMANN SUMS -->
    <div id="content-riemann" style="display: block; padding: 15px;">
        <div style="background: #fafafa; padding: 10px; border: 1px solid #eee; margin-bottom: 10px; border-radius: 4px;">
            <label style="font-weight: bold;">Rectangles (N): <span id="disp-rie-n">5</span></label>
            <input type="range" id="input-rie-n" min="2" max="50" step="1" value="5" style="vertical-align: middle; margin-left: 10px;">
            <div style="margin-top: 5px; font-family: monospace; color: #333;">
                Area ≈ <span id="disp-rie-sum" style="color: #d32f2f; font-weight: bold;">0.00</span>
                <span style="color: #777; font-size: 0.9em; margin-left: 10px;">( f(x) = 1 + 0.1x² + 0.5sin(2x) )</span>
            </div>
        </div>
        <!-- IMPORTANT: Explicit height prevents collapse -->
        <div id="plot-riemann-div" style="width: 100%; height: 400px;"></div>
    </div>

    <!-- TAB 2: LINE INTEGRAL -->
    <div id="content-line" style="display: none; padding: 15px;">
        <div style="background: #fafafa; padding: 10px; border: 1px solid #eee; margin-bottom: 10px; border-radius: 4px; display: flex; align-items: center; flex-wrap: wrap; gap: 15px;">
            <div>
                <label style="font-weight: bold;">Segments (N): <span id="disp-line-n">10</span></label>
                <input type="range" id="input-line-n" min="2" max="40" step="1" value="10" style="vertical-align: middle;">
            </div>
            <button id="btn-clear-path" style="background: #d32f2f; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">Clear Path</button>
            <div style="font-family: monospace; color: #333;">
                Work ≈ <span id="disp-line-work" style="color: #d32f2f; font-weight: bold;">0.00</span>
            </div>
        </div>
        
        <!-- Canvas Container with explicit relative positioning -->
        <div id="canvas-wrapper" style="width: 100%; height: 400px; position: relative; border: 1px solid #eee; background: #fff;">
            <canvas id="canvas-line" style="display: block; width: 100%; height: 100%; cursor: crosshair; touch-action: none;"></canvas>
            <div style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 5px 8px; pointer-events: none; border: 1px solid #ccc; font-size: 0.85em; border-radius: 4px;">
                Draw with mouse/touch<br>
                <span style="color: #d32f2f; font-weight: bold;">Red: Force</span> | <span style="color: #2e7d32; font-weight: bold;">Green: Displacement</span>
            </div>
        </div>
    </div>

</div>

<script>
// Use IIFE to isolate variables from the rest of the page
(function() {
    // --- ELEMENTS ---
    const btnTabRie = document.getElementById('btn-tab-riemann');
    const btnTabLine = document.getElementById('btn-tab-line');
    const contentRie = document.getElementById('content-riemann');
    const contentLine = document.getElementById('content-line');
    
    const inputRieN = document.getElementById('input-rie-n');
    const dispRieN = document.getElementById('disp-rie-n');
    const dispRieSum = document.getElementById('disp-rie-sum');
    const plotRieDiv = document.getElementById('plot-riemann-div');

    const inputLineN = document.getElementById('input-line-n');
    const dispLineN = document.getElementById('disp-line-n');
    const dispLineWork = document.getElementById('disp-line-work');
    const btnClearPath = document.getElementById('btn-clear-path');
    const canvas = document.getElementById('canvas-line');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const ctx = canvas.getContext('2d');

    // --- TAB LOGIC ---
    function setActiveTab(tab) {
        if (tab === 'riemann') {
            contentRie.style.display = 'block';
            contentLine.style.display = 'none';
            btnTabRie.style.borderBottomColor = '#1976d2';
            btnTabRie.style.color = '#1976d2';
            btnTabLine.style.borderBottomColor = 'transparent';
            btnTabLine.style.color = '#555';
            
            // Trigger Plotly resize after tab switch
            if (window.Plotly) Plotly.Plots.resize(plotRieDiv);
        } else {
            contentRie.style.display = 'none';
            contentLine.style.display = 'block';
            btnTabRie.style.borderBottomColor = 'transparent';
            btnTabRie.style.color = '#555';
            btnTabLine.style.borderBottomColor = '#1976d2';
            btnTabLine.style.color = '#1976d2';
            
            resizeCanvas();
        }
    }

    btnTabRie.onclick = () => setActiveTab('riemann');
    btnTabLine.onclick = () => setActiveTab('line');

    // ==========================================
    // 1. RIEMANN SUMS
    // ==========================================
    function f(x) {
        return 1 + 0.1 * x * x + 0.5 * Math.sin(2 * x);
    }

    function updateRiemann() {
        const N = parseInt(inputRieN.value);
        dispRieN.innerText = N;
        
        const a = 0, b = 6;
        const dx = (b - a) / N;
        
        // Curve
        const xSmooth = [], ySmooth = [];
        for(let x=a; x<=b; x+=0.05) {
            xSmooth.push(x);
            ySmooth.push(f(x));
        }

        // Rectangles
        const xRect = [], yRect = [];
        let area = 0;
        for(let i=0; i<N; i++) {
            let xi = a + i*dx;
            let val = f(xi);
            xRect.push(xi + dx/2);
            yRect.push(val);
            area += val * dx;
        }
        
        dispRieSum.innerText = area.toFixed(4);

        const data = [
            {
                x: xRect, y: yRect, width: dx*0.9, type: 'bar',
                marker: { color: 'rgba(50, 171, 96, 0.6)', line: {color: 'rgba(50, 171, 96, 1)', width: 1} },
                name: 'Riemann Sum'
            },
            {
                x: xSmooth, y: ySmooth, mode: 'lines',
                line: { color: '#1976d2', width: 3 },
                name: 'f(x)'
            }
        ];

        const layout = {
            margin: { t: 10, l: 40, r: 10, b: 30 },
            xaxis: { title: 'x' },
            yaxis: { title: 'f(x)', range: [0, 5] },
            showlegend: false,
            autosize: true
        };

        Plotly.newPlot(plotRieDiv, data, layout, {responsive: true, displayModeBar: false});
    }

    inputRieN.addEventListener('input', updateRiemann);

    // ==========================================
    // 2. LINE INTEGRAL (CANVAS)
    // ==========================================
    let pathPoints = [];
    let isDrawing = false;

    function resizeCanvas() {
        const rect = canvasWrapper.getBoundingClientRect();
        if(rect.width > 0 && rect.height > 0) {
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawScene();
        }
    }

    function getField(cx, cy, w, h) {
        // Simple rotation field relative to center
        const mx = (cx - w/2) / (w/4);
        const my = -(cy - h/2) / (h/4); // Y inverted for math
        return { fx: -my, fy: mx * 0.5 };
    }

    function drawArrow(x, y, dx, dy, color) {
        const head = 6;
        const angle = Math.atan2(dy, dx);
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + dy);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.moveTo(x + dx, y + dy);
        ctx.lineTo(x + dx - head*Math.cos(angle-Math.PI/6), y + dy - head*Math.sin(angle-Math.PI/6));
        ctx.lineTo(x + dx - head*Math.cos(angle+Math.PI/6), y + dy - head*Math.sin(angle+Math.PI/6));
        ctx.fill();
    }

    function drawScene() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0,0,w,h);

        // Grid (Field)
        const step = 40;
        for(let y=20; y<h; y+=step) {
            for(let x=20; x<w; x+=step) {
                const f = getField(x,y,w,h);
                drawArrow(x, y, f.fx*15, -f.fy*15, '#e0e0e0');
            }
        }

        // Path
        if(pathPoints.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = '#1976d2';
            ctx.lineWidth = 2;
            ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
            for(let i=1; i<pathPoints.length; i++) ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
            ctx.stroke();
        }

        // Vectors & Work
        if(pathPoints.length > 1) {
            const N = parseInt(inputLineN.value);
            dispLineN.innerText = N;

            // Calc Lengths
            let dists = [0], totalLen = 0;
            for(let i=1; i<pathPoints.length; i++) {
                let dx = pathPoints[i].x - pathPoints[i-1].x;
                let dy = pathPoints[i].y - pathPoints[i-1].y;
                totalLen += Math.sqrt(dx*dx + dy*dy);
                dists.push(totalLen);
            }

            // Resample
            let work = 0;
            let samplePts = [];
            for(let k=0; k<=N; k++) {
                let target = (k/N) * totalLen;
                // Find index
                let idx = 0;
                while(idx < dists.length-1 && dists[idx+1] < target) idx++;
                let t = (target - dists[idx]) / (dists[idx+1] - dists[idx] || 1);
                let p1 = pathPoints[idx];
                let p2 = pathPoints[idx+1] || p1;
                samplePts.push({
                    x: p1.x + (p2.x - p1.x)*t,
                    y: p1.y + (p2.y - p1.y)*t
                });
            }

            // Draw
            for(let i=0; i<N; i++) {
                let p1 = samplePts[i];
                let p2 = samplePts[i+1];
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                
                let mx = (p1.x+p2.x)/2;
                let my = (p1.y+p2.y)/2;
                let f = getField(mx, my, w, h);
                
                // Work calc (normalized)
                work += (f.fx * (dx/100) + f.fy * (-dy/100));

                drawArrow(p1.x, p1.y, dx, dy, '#2e7d32'); // Disp
                drawArrow(p1.x, p1.y, f.fx*25, -f.fy*25, '#d32f2f'); // Force
                
                ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(p1.x, p1.y, 3, 0, 6.28); ctx.fill();
            }
            dispLineWork.innerText = (work*5).toFixed(2);
        }
    }

    // Interaction
    function getXY(e) {
        const r = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - r.left, y: clientY - r.top };
    }

    canvas.addEventListener('mousedown', e => { isDrawing=true; pathPoints=[getXY(e)]; drawScene(); });
    window.addEventListener('mousemove', e => { 
        if(!isDrawing) return; 
        pathPoints.push(getXY(e)); 
        drawScene(); 
    });
    window.addEventListener('mouseup', () => { isDrawing=false; drawScene(); });

    // Touch
    canvas.addEventListener('touchstart', e => { 
        e.preventDefault(); // Stop scroll inside canvas ONLY
        isDrawing=true; 
        pathPoints=[getXY(e)]; 
        drawScene(); 
    }, {passive:false});
    
    window.addEventListener('touchmove', e => { 
        if(isDrawing) {
             e.preventDefault(); 
             pathPoints.push(getXY(e)); 
             drawScene(); 
        }
    }, {passive:false});
    
    window.addEventListener('touchend', () => isDrawing=false);

    btnClearPath.onclick = () => { pathPoints=[]; dispLineWork.innerText="0.00"; drawScene(); };
    inputLineN.oninput = drawScene;

    // INIT
    setActiveTab('riemann');
    updateRiemann();
    // Safety timeout for Plotly to render after DOM placement
    setTimeout(() => {
        updateRiemann();
        resizeCanvas();
    }, 500);

})();
</script>
```


## Differential equations

### Starting example

Let's consider the first order differential equation

$$
\frac{dy(x)}{dx} = 2x
$$

Let us think how we should read this equation. The left hand side is the derivative of the function $y(x)$ with respect to $x$. This derivative is equal to $2x$. This equation tells us how the function $y(x)$ changes with $x$. The function $y(x)$ changes at a rate of $2x$ with respect to $x$. This is a simple differential equation that can be solved by integration.
$$
y(x) = x^2 + C
$$

where $C$ is an integration constant. This is the general solution of the differential equation. The solution is not unique because the constant $C$ can take any value. 

```{python}
import numpy as np
import matplotlib.pyplot as plt

def y(x, C):
    return x**2 + C

x = np.linspace(0, 10, 100)

fig, ax = plt.subplots(figsize=(6, 4))

for C in range(-50, 50, 10):
    plt.plot(x, y(x, C), label=f'C={C}')

plt.xlabel('x')
plt.ylabel('y')
plt.show()
```


##### Numerical solution

Remember that derivatives can be approximated by finite differences. The derivative of a function $f(x)$ can be approximated by

$$
\frac{df(x)}{dx} \approx \frac{f(x + h) - f(x)}{h}
$$

where $h$ is a small number. This is a simple way to approximate the derivative of a function. Let's use this approximation to solve the differential equation

$$
\frac{dy(x)}{dx} = 2x
$$

We can approximate the derivative by

$$
\frac{y(x + h) - y(x)}{h} = 2x
$$

This equation can be solved for $y(x + h)$

$$
y(x + h) = y(x) + 2xh
$$

This equation can be used to solve the differential equation numerically. We can start from an initial value of $y(x)$ and use the equation above to calculate the value of $y(x + h)$. This value can be used to calculate the next value of $y(x + 2h)$ and so on:

* Step 1 -  we know value of $y$ for a given $x$ which is 

$$y(x)$$

* Step 2 - we can calculate the value of $y$ for the next point $x + h$ using 

$$y(x + h) = y(x) + 2xh$$

* Step 3 - we can calculate the value of $y$ for the next point $x + 2h$ using 

$$y(x + 2h) = y(x + h) + 2(x + h)h$$

* Step 4 - we can calculate the value of $y$ for the next point $x + 3h$ using 

$$y(x + 3h) = y(x + 2h) + 2(x + 2h)h$$

* and so on

Let us compare the numerical solution with the analytical solution.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Define the derivative dy/dx
def dy_dx(x):
    return 2 * x

# Define the exact analytical solution y(x) for comparison
def y_analytical(x):
    return x**2

# Define a numerical solution for y(x) using the forward Euler method
def y_numerical(x, h):
    y = [0]  # Initialize y with the starting value, assuming y(0) = 0
    for i in range(len(x) - 1):
        y.append(y[-1] + dy_dx(x[i]) * h)  # Update y using dy/dx
    return y

# Set up the x values
plot_x = np.linspace(0, 10, 100)
x = np.linspace(0, 10, 10)
h = x[1] - x[0]  # Step size

# Compute the difference between analytical and numerical solutions
difference = y_analytical(x) - np.array(y_numerical(x, h))

# Set up the figure with two subplots
fig, axs = plt.subplots(2,1, figsize=(10,8))

# Left plot: Analytical and numerical solutions
axs[0].plot(plot_x, y_analytical(plot_x), label='Analytical', linestyle='dashed', linewidth=2)
axs[0].scatter(x, y_numerical(x, h), label='Numerical', linestyle='solid', color='red')
axs[0].set_title('Analytical vs Numerical')
axs[0].set_xlabel('x')
axs[0].set_ylabel('y')
axs[0].legend()

# Right plot: Difference between solutions
axs[1].scatter(x, difference, label='Difference', color='red')
axs[1].set_title('Difference (Analytical - Numerical)')
axs[1].set_xlabel('x')
axs[1].set_ylabel('Difference')
axs[1].legend()

# Adjust layout and show the plots
plt.tight_layout()
plt.show()

```

Difference between the analytical and numerical solutions depends on the step size $h$. 

### Second order differential equations

Let's consider the second order differential equation

$$
\frac{d^2y(x)}{dx^2} = -y(x)
$$

This is a simple differential equation that can be solved by integration. The solution is

$$
y(x) = A \sin(x) + B \cos(x)
$$

where $A$ and $B$ are integration constants. This is the general solution of the differential equation. The solution is not unique because the constants $A$ and $B$ can take any value. The solution is a sinusoidal function. The constants $A$ and $B$ determine the amplitude and phase of the sinusoidal function.

#### Numerical solution

From Taylor's theorem, we know that the second derivative of a function $f(x)$ can be approximated by

$$
f(x + h) = f(x) + h \frac{df(x)}{dx} + \frac{h^2}{2} \frac{d^2f(x)}{dx^2} + \ldots
$$

also

$$
f(x - h) = f(x) - h \frac{df(x)}{dx} + \frac{h^2}{2} \frac{d^2f(x)}{dx^2} + \ldots
$$

adding these two equations we get

$$
f(x + h) + f(x - h) = 2 f(x) + h^2 \frac{d^2f(x)}{dx^2}
$$

so we can approximate the second derivative by

$$
\frac{f(x + h) + f(x - h) - 2 f(x)}{h^2} \approx \frac{d^2f(x)}{dx^2}
$$

Let's use this approximation to solve the differential equation

$$
\frac{d^2y(x)}{dx^2} = -y(x)
$$

We can approximate the second derivative by

$$
\frac{y(x + h) + y(x - h) - 2 y(x)}{h^2} = -y(x)
$$

This equation can be solved for $y(x + h)$

$$
y(x + h) = 2 y(x) - y(x - h) - h^2 y(x)
$$

This equation can be used to solve the differential equation numerically. We can start from an initial value of $y(x)$ and $y(x - h)$ and use the equation above to calculate the value of $y(x + h)$. This value can be used to calculate the next value of $y(x + 2h)$ and so on. This is a simple numerical method to solve differential equations.

Let us compare the numerical solution with the analytical solution.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Define the second derivative d^2y/dx^2
def d2y_dx2(x):
    return -x

# Define the exact analytical solution y(x) for comparison
def y_analytical(x):
    return -np.sin(x)

# Define a numerical solution for y(x) using the forward Euler method
def y_numerical(x, h):
    y = [0, np.sin(-h)]  # Initialize y with the starting values, assuming y(0) = 0 and y(-h) = sin(-h)
    for i in range(1, len(x) - 1):
        y.append(2 * y[-1] - y[-2] - h**2 * y[-1])  # Update y using d^2y/dx^2
    return y

# Set up the x values
plot_x = np.linspace(0, 10, 100)
x = np.linspace(0, 10, 20)
h = x[1] - x[0]  # Step size

# Compute the difference between analytical and numerical solutions
difference = y_analytical(x) - np.array(y_numerical(x, h))

# Set up the figure with two subplots
fig, axs = plt.subplots(2,1, figsize=(10,8))

# Left plot: Analytical and numerical solutions
axs[0].plot(plot_x, y_analytical(plot_x), label='Analytical', linestyle='dashed', linewidth=2)
axs[0].scatter(x, y_numerical(x, h), label='Numerical', color='red')
axs[0].set_title('Analytical vs Numerical')
axs[0].set_xlabel('x')

axs[0].set_ylabel('y')
axs[0].legend()

# Right plot: Difference between solutions
axs[1].scatter(x, difference, label='Difference')
axs[1].set_title('Difference (Analytical - Numerical)')
axs[1].set_xlabel('x')
axs[1].set_ylabel('Difference')
axs[1].legend()

# Adjust layout and show the plots
plt.tight_layout()
plt.show()
```


## Gradient

The **gradient** of a scalar field is itself a vector field that points in the direction of the greatest rate of increase of that scalar field. Its magnitude indicates how rapidly the value of the scalar field changes. Formally, for a function $f(x, y, z)$, the gradient is:

$$
\nabla f = \left( \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z} \right).
$$

If a function $f$ is defined in 2D space as $f(x, y)$, then

$$
\nabla f(x, y) = \left( \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \right).
$$

::: warning
Any scalar field $f(x, y)$ has a corresponding gradient field $\nabla f$. **However**, not every vector field is necessarily the gradient of some scalar field.  
:::

---

### 1D Example

For a one-dimensional function $f(x) = \sin(x)$ on the interval $[0, 10]$, the gradient (or in this 1D case, simply the derivative) is:

$$
f'(x) = \cos(x).
$$

Below is a Python example that illustrates how to compute these derivatives at a few sample points. We then represent them as small vectors placed at $y = 2$ in a plot, pointing upward if $f'(x)$ is positive and downward if $f'(x)$ is negative, with a scaled magnitude.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# 1D function
def f(x):
    return np.sin(x)

# Its derivative (gradient in 1D)
def df(x):
    return np.cos(x)

# Sample points on [0, 10]
xs = np.linspace(0, 10, 100)
values_f = f(xs)

# Choose a few points to visualize gradient vectors
sample_points = np.linspace(0, 10, 20)
grad_values = df(sample_points)

fig, ax = plt.subplots(figsize=(8, 4))

# Plot sin(x)
ax.plot(xs, values_f, label='f(x) = sin(x)')

# Plot gradient vectors at y=2 for each sample point
for x_i, grad in zip(sample_points, grad_values):
    # We'll scale the arrow length by 0.5 for visibility
    ax.arrow(
        x_i, f(x_i), grad,0 ,
        head_width=0.1, head_length=0.1, length_includes_head=True,
        fc='green', ec='red'
    )

ax.set_ylim(-1.5, 2)
ax.set_xlabel('x')
ax.set_ylabel('f(x)')
ax.set_title('1D Gradient (Derivative) of sin(x)')
ax.legend()
plt.show()
```

In this plot:
- The blue curve is $\sin(x)$.
- The red arrows at show the derivative $f'(x) = \cos(x)$ at the chosen sample points.
  - Arrows pointing up indicate a positive derivative.


---

### 2D Example

Now let’s consider a scalar field in two variables. For instance:

$$
f(x, y) = \sin(x)\cos(y).
$$

Let us compute partial derivatives of this function. Derivative with respect to $x$ is:

$$
\frac{\partial f(x,y)}{\partial x} = \frac{\partial}{\partial x}[\sin(x)\cos(y)] = \cos(x)\cos(y).
$$

Derivative with respect to $y$ is:

$$
\frac{\partial f(x,y)}{\partial y} = \frac{\partial}{\partial y}[\sin(x)\cos(y)] = -\sin(x)\sin(y).
$$

so the gradient of the function $f(x, y)$ is:

$$
\nabla f(x, y) = 
\bigl(\cos(x)\cos(y),\; -\sin(x)\sin(y)\bigr).
$$

```{python}
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Define the 2D scalar field
def f2d(x, y):
    return np.sin(x) * np.cos(y)

# Create a grid for plotting
nx, ny = 60, 60
x_vals = np.linspace(0, 2*np.pi, nx)
y_vals = np.linspace(0, 2*np.pi, ny)
X, Y = np.meshgrid(x_vals, y_vals)
Z = f2d(X, Y)

# --- 3D Surface Plot ---
fig3d = plt.figure(figsize=(8, 6))
ax3d = fig3d.add_subplot(111, projection='3d')

# Create a surface plot
surf = ax3d.plot_surface(
    X, Y, Z, 
    cmap='coolwarm', 
    edgecolor='none',
    alpha=0.9
)
fig3d.colorbar(surf, ax=ax3d, shrink=0.6, label='f(x,y) = sin(x)*cos(y)')
ax3d.set_xlabel('x')
ax3d.set_ylabel('y')
# ax3d.set_zlabel('f(x,y)')
ax3d.set_title('3D Surface of f(x, y) = sin(x)*cos(y)')
plt.show()
```


Below is a Python example that:
1. Plots a heatmap of $f(x, y)$.
2. Overlays gradient vectors (arrows) on a grid of points.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Define the 2D scalar field
def f2d(x, y):
    return np.sin(x) * np.cos(y)

# Define partial derivatives (gradient)
def grad_f2d(x, y):
    # df/dx = cos(x)*cos(y)
    # df/dy = -sin(x)*sin(y)
    return np.cos(x)*np.cos(y), -2*np.sin(x)*np.sin(y)

# Create a grid for plotting
nx, ny = 60, 60
x_vals = np.linspace(0, 2*np.pi, nx)
y_vals = np.linspace(0, 2*np.pi, ny)
X, Y = np.meshgrid(x_vals, y_vals)
Z = f2d(X, Y)

# Compute gradient on a coarser grid for quiver plot
skip = 3
x_quiv = X[::skip, ::skip]
y_quiv = Y[::skip, ::skip]
Fx, Fy = grad_f2d(x_quiv, y_quiv)

fig, ax = plt.subplots(figsize=(8, 6))

# Heatmap of f(x,y)
c = ax.imshow(
    Z, 
    extent=[x_vals.min(), x_vals.max(), y_vals.min(), y_vals.max()],
    origin='lower',
    cmap='coolwarm'
)
fig.colorbar(c, ax=ax, label='f(x,y) = sin(x)*cos(y)')

# Quiver plot of gradient vectors
ax.quiver(
    x_quiv, y_quiv, Fx, Fy, 
    color='black', 
    pivot='mid', 
    alpha=0.8,
    width=0.003,
    scale=50
)

ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('Gradient of f(x, y) = sin(x)*cos(y)')
plt.show()
```

**Interpretation**:

- The **heatmap** shows the values of $f(x,y)$. Red/blue corresponds to high/low values of the scalar field.
- The **arrows** show the local direction and magnitude of the gradient, i.e., where $f(x, y)$ increases the most and how quickly.

This demonstrates how any scalar field (like temperature, potential, or pressure) naturally defines a vector field via its gradient. However, **not every vector field arises as a gradient** of a scalar field—certain mathematical conditions (like having zero curl in a simply connected domain) must be satisfied for a vector field to be the gradient of some scalar field.
